## 状态压缩DP之玉米田

![image-20210323094306976](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\dp\state\状态压缩DP之玉米田.assets\image-20210323094306976.png)



```C++
/**
2 3
1 1 0
0 1 0
**/

m = 3 的时候，有1<<m = 8 个状态：
000 001 010 011 100 101 110 111
合法的状态:!(i&i>>1)  //看相邻位是否是打印0 大于0是True，小于0是false
000 001 010 100 101 
//如  i =101  i & i>>1  = 101 & 010  =0 取反，为True
  

```



```C++

#include <iostream>
#include <stdio.h>
#include "stdio.h"
using namespace std;

const int MOD = 1e9;
int n, m;           //玉米田的行数，列数
int g[14];          //各行的状态值
int cnt;            //同一行合法状态的个数
int s[1 << 14];     //一行合法的状态集合
int f[14][1 << 14]; //f[i,a]表示已经种植前i行，第i行第a个状态时的方案数

main(int argc, char const *argv[])
{
    cin >> n >> m; //输入行数列数
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            int x;
            cin >> x;
            g[i] = (g[i] << 1) + x; //保存各行的状态值
        }
    }
    for (int i = 0; i < (1 << m); i++) //枚举每一行的所有状态
    {
        if (!(i & i >> 1)) //如果不存在相邻的1
        {
            s[cnt++] = i; //保存每一行的合法状态
        }
    }
    //状态计算
    f[0][0] = 1;                          //什么都不种也是一种方案
    for (int i = 1; i <= n + 1; i++)      //枚举行
        for (int a = 0; a < cnt; a++)     //枚举第i行的合法状态
            for (int b = 0; b < cnt; b++) //枚举第i-1行的合法状态
            {
                //a种在肥沃的土地上，a，b同列不同时为1
                if ((s[a] & g[i]) == s[a] && !(s[a] & s[b]))  //-->1位置
  				 //if ((s[a] & g[i]) == s[a] && (s[b] & g[i - 1]) == s[b] && !(s[a] & s[b]))//-->2位置  b也种在肥沃的土地上
                {	
                    f[i][a] = (f[i][a] + f[i - 1][b]) % MOD;
                    printf("f[%d %d]=%d ", i, a, f[i][a]);
                    printf("f[%d %d]=%d\n", i - 1, b, f[i - 1][b]);
                }
            }
    printf("%d\n", f[n + 1][0]); //相当于只在第1—~n行上种植
}
```

- 对于1位置来说

```java
f[1 0]=1 f[0 0]=1
f[1 0]=1 f[0 1]=0
f[1 0]=1 f[0 2]=0
f[1 0]=1 f[0 3]=0
f[1 0]=1 f[0 4]=0
f[1 2]=1 f[0 0]=1
f[1 2]=1 f[0 1]=0
f[1 2]=1 f[0 3]=0
f[1 2]=1 f[0 4]=0
f[1 3]=1 f[0 0]=1
f[1 3]=1 f[0 1]=0
f[1 3]=1 f[0 2]=0
    //
//b: 000 001 010 100 101
//a: 000 001 010 100 101
//g[1] = 110
//当a选到3位置 100 时， 对应的可以选的b  000 001 010 满足： !(s[a] & s[b])   a，b同列不同时为1
f[2 0]=1 f[1 0]=1
f[2 0]=1 f[1 1]=0
f[2 0]=2 f[1 2]=1
f[2 0]=3 f[1 3]=1
f[2 0]=3 f[1 4]=0
f[2 1]=1 f[1 0]=1
f[2 1]=2 f[1 2]=1
f[2 1]=3 f[1 3]=1
f[2 2]=1 f[1 0]=1
f[2 2]=1 f[1 1]=0
f[2 2]=2 f[1 3]=1
f[2 2]=2 f[1 4]=0
//b: 000 001 010 100 101
//a: 000 001 010 100 101
//g[2] = 011   000 001 010可以种植在这一行的土地上 (s[a] & g[i]) == s[a] 
//对于a的 010来说，可以和b的000 001  100 101 （对应的编号是0 1 3 4 ）
//
f[3 0]=3 f[2 0]=3
f[3 0]=6 f[2 1]=3
f[3 0]=8 f[2 2]=2
f[3 0]=8 f[2 3]=0
f[3 0]=8 f[2 4]=0
//b: 000 001 010 100 101
//a: 000 001 010 100 101
//g[3] = 000   当前行合法的只有000这一个
//对于a的 010来说，可以和b的000 001 010 100 101 （对应的编号是0 1 2 3 4 ）
//    
```

- 对于2位置来说

```
f[1 0]=1 f[0 0]=1
f[1 2]=1 f[0 0]=1
f[1 3]=1 f[0 0]=1
f[2 0]=1 f[1 0]=1
f[2 0]=2 f[1 2]=1
f[2 0]=3 f[1 3]=1
f[2 1]=1 f[1 0]=1
f[2 1]=2 f[1 2]=1
f[2 1]=3 f[1 3]=1
f[2 2]=1 f[1 0]=1
f[2 2]=2 f[1 3]=1
f[3 0]=3 f[2 0]=3
f[3 0]=6 f[2 1]=3
f[3 0]=8 f[2 2]=2
```

### 总结

- 1.用二进制表示状态，用十进制数存储状态
- 2.用位运算筛选合法状态
- 3.用位运算判断状态转移的条件
- 4.计算时每个类累加上一行的兼容类





