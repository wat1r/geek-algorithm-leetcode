## 动态规划解路径之地下城游戏[Lord Squirrel]

![squirrel-3757569_640](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\dp\paths\动态规划解路径之地下城游戏[Lord Squirrel].assets\squirrel-3757569_640.jpg)



### 方法1：模板法DP

####  一个模型三个特征

##### 一个模型:

- 动态规划解决问题的模型

##### 三个特征：

- **最优子结构**：最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面状态推导出来。
- **无后效性**：无后效性，有两层含义，第一层含义是，在推导后面阶段状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。
- **重复子问题**：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

>  下面这张图是64题最小路径和的分析：

![2020-07-15_204721](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\dp\paths\动态规划解路径之地下城游戏[Lord Squirrel].assets\2020-07-15_204721.jpg)

走到$[i,j]$这个位置，我们只能通过$[i-1,j]$,$[i,j-1]$这两个位置移过来，也就是说，我们想要计算$[i,j]$位置对应的状态，只需要关心$[i-1,j]$,$[i,j-1]$这两个位置的状态，并不关心是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变。所以这个问题，**符合“无后效性”**

> 对于本题呢？

对于每一条路径，我们需要同时记录两个值。第一个是**从出发点到当前点的路径和**，第二个是**从出发点到当前点所需的最小初始值**

对于从开始位置$[0,0]$到$[1,2]$这个点，有两条路径

![2020-07-16_093555](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\dp\paths\动态规划解路径之地下城游戏[Lord Squirrel].assets\2020-07-16_093555.jpg)

- 对于路径1：**从出发点到当前点的路径和**为1(0+(-2)+3+0)，**从出发点到当前点所需的最小初始值**为3(因为要确保每一步的体力值值至少为正数)
- 对于路径2：**从出发点到当前点的路径和**为-1(0+(-1)+0+0)，**从出发点到当前点所需的最小初始值**为2(因为要确保每一步的体力值值至少为正数)
- 目标是**从出发点到当前点的路径和**越大越好，**从出发点到当前点所需的最小初始值**越小越好

如果从左上角的点$[0,0]$走到右下角的点$[2,2]$(也就是红色填充块的位置)，走路径1是，只需要体力值为3即可走到终点，过程是$3+0+(-2)+3+0+(-2)$ = $2$,走路径2的话，需要体力值为4才可走到终点，$4+0+(-1)+0+0+(-2)$=$1$, 这时候优先路径1，但是如果终点是黄色填充块的位置，路径2优先

- 因此，从左上角的位置开始走的话，因为两个因素的制约，无法选择到达右下角的最优方案，**不符合“无后效性”**

#### 状态定义：

- 在这里，可以放弃路径和因素，考虑**当前点所需要的的最小初始值**，$dp[i,j]$表示从$[i,j]$走到终点，需要的最小的初始值
- 从底往上走，$[i,j]$与$[i+1,j]$和$[i,j+1]$有关，这两个点，哪个点需要的初始值小，从$[i,j]$出发就选哪一个，当前位置的值是$dungeon[i,j]$,从$[i+1,j]$和$[i,j+1]$推导过来，需要减去这个值，也就是$min(dp[i+1,j]dp[i,j+1])-dungeon[i,j]$，但是每一步的体力值不能至少为1，所以：
  - $dp[i,j]=max(min(dp[i+1,j]dp[i,j+1])-dungeon[i,j],1)$

- 返回$dp[0,0]$即为答案

#### 元方法

利用模板法大体分三步:

- 计算$dp$表的第一行
- 计算$dp$表的第一列
- 计算$dp$表的一般情况，直到填充完$dp$表，方可结束

```java
    public int calculateMinimumHP(int[][] dungeon) {
        if (dungeon == null || dungeon.length == 0) return 0;
        int row = dungeon.length, col = dungeon[0].length;
        int[][] dp = new int[row][col];
        dp[row - 1][col - 1] = Math.max(1, 1 - dungeon[row - 1][col - 1]);
        //第row-1行：最后一行
        for (int j = col - 2; j >= 0; j--) {
            dp[row - 1][j] = Math.max(1, dp[row - 1][j + 1] - dungeon[row - 1][j]);
        }
        //第col-1列：最后一列
        for (int i = row - 2; i >= 0; i--) {
            dp[i][col - 1] = Math.max(1, dp[i + 1][col - 1] - dungeon[i][col - 1]);
        }
        //一般情况
        for (int i = row - 2; i >= 0; i--) {
            for (int j = col - 2; j >= 0; j--) {
                dp[i][j] = Math.max(Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1);
            }
        }
        return dp[0][0];
    }
```

#### **复杂度分析**:

- 时间复杂度：$O(M*N)$ 
- 空间复杂度： $O(M*N)$  $MN$是格子的行列

### Reference

- [**动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题**](***https://blog.csdn.net/every__day/article/details/88174082***)

- [官方题解](https://leetcode-cn.com/problems/dungeon-game/solution/di-xia-cheng-you-xi-by-leetcode-solution/)

