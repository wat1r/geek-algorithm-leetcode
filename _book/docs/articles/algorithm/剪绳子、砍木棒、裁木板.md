## 剪绳子、砍木棒、裁木板

### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

同[剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/)，同类问题有cutting rod，参考链接：[畅游面试中的动态规划套路-完全背包系列](https://blog.csdn.net/wat1r/article/details/118311292)

#### 方法1：暴力递归

- TLE

```java
        public int integerBreak(int n) {
            if (n < 2) return n;
            return dfs(n);
        }

        private int dfs(int n) {
            //n= 2 只能拆成 1+1
            if (n == 2) return 1;
            int res = 0;
            //当前摘取 i 剩下的是 n -i
            //case1：i 和 n-i 形成两段，算乘积， 不拆n-i
            //case2: i 和 n-i拆过的最大值 算乘积 拆 n-i
            for (int i = 1; i < n; i++) {
                res = Math.max(res, Math.max(i * (n - i), i * dfs(n - i)));
            }
            return res;
        }
```

#### 方法2：记忆化递归

```java
				//k：当前数字x 做拆分，能获得的最大的乘积
        Map<Integer, Integer> memo = new HashMap<>()

        public int integerBreak(int n) {
            if (n < 2) return n;
            return dfs(n);
        }

        private int dfs(int n) {
            if (memo.containsKey(n)) return memo.get(n);
            //n= 2 只能拆成 1+1
            if (n == 2) return 1;
            int res = 0;
            //当前摘取 i 剩下的是 n -i
            //case1：i 和 n-i 形成两段，算乘积， 不拆n-i
            //case2: i 和 n-i拆过的最大值 算乘积 拆 n-i
            for (int i = 1; i < n; i++) {
                res = Math.max(res, Math.max(i * (n - i), i * dfs(n - i)));
            }
            memo.put(n, res);
            return res;
        }	
```

#### 方法3：动态规划

- `dp[i]`表示拆分i这个数，获得的最大乘积

- 当 i>=2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j<i），则有以下两种方案：

  - 将 i 拆分成 j 和 i-j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是j * (i - j)；

  - 将 i 拆分成 j 和 i-j的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j * dp[i - j]。

```java
        public int integerBreak(int n) {
            int[] dp = new int[n + 1];
            dp[1] = 1;
            for (int i = 2; i <= n; i++) {
                //从 1枚举到 j 至少留 i-j >=1
                for (int j = 1; j < i; j++) {
                    //选了j 可以对i-j这部分做两个选择：
                    //选择1： 不拆分 i-j 得到的结果是 j * (i - j)
                    //选择2： 拆分 i-j,要拿拆分的 [i-j]这部分的最大值 j * dp[i - j]
                    dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
                }
            }
            return dp[n];
        }
```

#### 方法4：数学

推导过程：[链接](https://leetcode.cn/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/)

##### 结论

将数字n拆分为尽量多的3，可以保证乘积最大。下面简单分类讨论：

- 若 n = 0(mod3)，即 n=3k，则拆分为 k个3
- 若 n =1(mod3)，即 n=3k+1=3(k−1)+2×2，则拆分为 k−1个3，2个2
- 若 n =2(mod3)，即 n=3k+2，则拆分为k个3，1个2

考虑到边界情况，当 n<=3时无法拆分，故直接讨论：

- 若 n=2，只有 2=1+1，此时最大值为 1
- 若 n=3，只有 3=1+2，此时最大值为 2
- 以上两种情形可以合并为：当 n <=3 时，最大值为 n-1

```java
        public int integerBreak(int n) {
            if (n <= 3) return n - 1;
            int a = n / 3, b = n % 3;
            if (b == 0) return (int) Math.pow(3, a);
            if (b == 1) return (int) Math.pow(3, a - 1) * 2 * 2;
            return (int) Math.pow(3, a) * 2;
        }
```



### [剑指 Offer 14- II. 剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/)

- **大数越界情况下的求余问题**

- **大数越界：** 剪绳子问题（不考虑取余）最终的结果是以3^a3*a*指数级别增长，可能超出 `int32` 甚至 `int64` 的取值范围，导致返回值错误。

推导：[链接](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/)

#### 方法1：大数取余

- 使用`BigInteger`库函数

```java
        public int cuttingRope(int n) {
            int MOD = (int) 1e9 + 7;
            BigInteger[] dp = new BigInteger[n + 1];
            Arrays.fill(dp, BigInteger.valueOf(1));
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j < i; j++) {
                    dp[i] = dp[i].max(BigInteger.valueOf(j * (i - j))).max(dp[i - j].multiply(BigInteger.valueOf(j)));
                }
            }
            return dp[n].mod(BigInteger.valueOf(MOD)).intValue();
        }
```

#### 方法2：循环取余

- 使用上一题的结论

```java
        public int cuttingRope(int n) {
            if (n == 1) return 1;
            if (n <= 3) return n - 1;
            int MOD = (int) 1e9 + 7;
            long res = 1;
            while (n > 4) {
                res *= 3;
                res %= MOD;
                n -= 3;
            }
            return (int) (n * res % MOD);
        }
```

#### 方法3：贪心+快速幂

- 使用上一题的贪心的结论

```java
        int MOD = (int) 1e9 + 7;

        public int cuttingRope(int n) {
            if (n < 4) return n - 1;
            int a = n / 3, b = n % 3;
            if (b == 0) return (int) (myPow(3, a) % MOD);
            else if (b == 1) return (int) (myPow(3, a - 1) * 4 % MOD);
            else return (int) (myPow(3, a) * 2 % MOD);
        }

        public long myPow(long base, int num) {
            long res = 1;
            while (num > 0) {
                if ((num & 1) == 1) {
                    res *= base;
                    res %= MOD;
                }
                base *= base;
                base %= MOD;
                num >>= 1;
            }
            return res;
        }
```



