> **matrix**



## 0.如何将一张图翻转90度

> **给定一张图片，如何将它旋转 90 度？** 
> **可以将图视为可以存储在缓冲区中的二维矩阵。 提供了矩阵维度和它的地址。 怎么转呢？**

- 下面的是个例子

```java
* * * ^ * * *
* * * | * * *
* * * | * * *   
* * * | * * *
```

顺时针翻转90度后，变成：

```java
* * * *
* * * *
* * * *
-- - - >
* * * *
* * * *
* * * *
```

想法很简单，将源矩阵的每一行转换为最终图的所需列，将使用辅助缓冲区来转换图。
从上图我们可以观察到

```java
源图的第一行 -> 目标图的最后一列
源图的第二行 -> 目标图的倒数第二列
...
源图的最后一行 -> 目标图的第一列
```

![](/imgs/articles/data_structures/matrix/image-20220323154837926.png)

如图：可以将m✖️n的矩阵转化为n✖️m矩阵，逻辑如下：

```java
private void rotate(int m, int n, int[][] source, int[][] dest) {
    for (int r = 0; r < m; r++) {
        for (int c = 0; c < n; c++) {
            dest[c][m - 1 - r] = source[r][c];
        }
    }
}
```

### 代码

```java
static class _1st {


    public static void main(String[] args) {
        _1st handler = new _1st();
        int[][] source = {{1, 2, 3, 4},
                {5, 6, 7, 8},
                {9, 10, 11, 12}};
        int m = source.length, n = source[0].length;
        handler.display(source, m, n);
        int[][] dest = new int[n][m];
        handler.rotate(m, n, source, dest);
        handler.display(dest, n, m);
    }


    /**
     * @param m      source的 row
     * @param n      source的 col
     * @param source 源矩阵
     * @param dest   目标矩阵
     */
    private void rotate(int m, int n, int[][] source, int[][] dest) {
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                dest[c][m - 1 - r] = source[r][c];
            }
        }
    }


    private void display(int[][] matrix, int R, int C) {
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                System.out.printf("%d\t", matrix[r][c]);
            }
            System.out.print("\n");
        }
    }

}
```

### 输出

```java
1	 2	3  	4	
5	 6	7 	8	
9	10	11	12	
-------------------  
9	  5	 1	
10	6  2	
11	7	 3	
12	8	 4
```

