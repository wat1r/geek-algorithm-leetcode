## 【重温经典】打家劫舍数题

## 打家劫舍

```java
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 
示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。


提示：

1 <= nums.length <= 100
0 <= nums[i] <= 400
```

### 方法1:暴力递归

```java
public int rob(int[] nums) {
    return helper(nums, nums.length - 1);
}

//偷了或没偷第i和房间，带来的收益
public int helper(int[] nums, int i) {
    if (i < 0) return 0;
  	//偷了第i个房间，则考虑第i-2个房间
    int steal = nums[i] + helper(nums, i - 2);
  	//没偷第i个房间，则考虑第i-1个房间
    int non_steal = helper(nums, i - 1);
  	//返回偷或者没偷带来的收益
    return Math.max(steal, non_steal);
}
```

### 方法2:自顶向下记忆化递归(Top-down)

> 从前往后跳

```java
Integer[] memo;

public int rob(int[] nums) {
    memo = new Integer[nums.length];
    return helper(nums, 0);
}

/**

 * @param nums
 * @param i    表示当前的房间号
 * @return
   */
   public int helper(int[] nums, int i) {
    //因为是从前往后偷，到达最后一个房间时，退出
   if (i >= nums.length) return 0;
   if (memo[i] != null) return memo[i];
   int steal = nums[i] + helper(nums, i + 2);
   int non_steal = helper(nums, i + 1);
   return memo[i] = Math.max(steal, non_steal);
   }
```

> 从后往前跳

```java
Integer[] memo;

public int rob(int[] nums) {
    memo = new Integer[nums.length];
    return helper(nums, nums.length - 1);
}

public int helper(int[] nums, int i) {
    if (i < 0) return 0;
    if (memo[i] != null) return memo[i];
    int steal = nums[i] + helper(nums, i - 2);
    int non_steal = helper(nums, i - 1);
    return memo[i] = Math.max(steal, non_steal);
}
```

### 方法3:自底向上填表DP(Bottom-up)

![image-20220305200741336](/Users/frankcooper/Library/Application Support/typora-user-images/image-20220305200741336.png)

#### 定义状态

- 定义`f[n][2]`
- `f[i][0]` 表示在第`i`间房子的时候，没偷，所获得的累计金额(房间索引从0开始)
- `f[i][1]` 表示在第`i`间房子的时候，偷了，所获得的累计金额

#### 转移方程

- `f[i][0]`与前一个房间的结果有关系，`f[i][0]`表示当前房间没偷，所以前一个房间是可以偷的，这是符合条件「**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**」即`f[i-1][1]`,如果前一个房间没偷呢？这也是可以的，也就是说当前房间和前一个房间都没有偷，即`f[i-1][0]`，取这两个值中的最大值，即`f[i][0]=max{f[i-1][1],f[i-1][0]}`
- `f[i][1]`与前一个房间的结果有关系，`f[i][1]`表示当前房间偷了，要符合条件「**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**」的话，需要前一个房间，一定是没有偷过的，即`f[i-1][0]`，再加上当前房间所获得的价值，即`f[i][1]=f[i-1][0]+nums[i]`

#### 初始化

- 第一间房间没有偷的时候，没有产生金额`f[0][0]=0`
- 第一间房间偷了的时候，产生了金额，即第一间房间的钱`f[0][1]=nums[0]`

```java
     public int rob(int[] nums) {
            int n = nums.length;
            int[][] f = new int[n][2];//0表示今天没偷 1表示偷了
            f[0][0] = 0;
            f[0][1] = nums[0];
            for (int i = 1; i < n; i++) {
                f[i][0] = Math.max(f[i - 1][0], f[i - 1][1]);
                f[i][1] = f[i - 1][0] + nums[i];
            }
            return Math.max(f[n - 1][0], f[n - 1][1]);
        }
```

- 也可以将`f[n][2]`设置成`f[n+1][2]`,计算房间产生的收益的时候，计算是`nums[i-1]`,代码如下：

```java
        public int rob(int[] nums) {
            int n = nums.length;
            int[][] f = new int[n + 1][2];
            for (int i = 1; i <= n; i++) {
                f[i][0] = Math.max(f[i - 1][0], f[i - 1][1]);
                f[i][1] = f[i - 1][0] + nums[i - 1];
            }
            return Math.max(f[n][0], f[n][1]);
        }
```

- 进而可以考虑移除掉`f[n][2]`中的第二维，定义`f[n+1]`,其中`f[i]`表示**偷**第`i`间房间时，产生的前`i`个房间即`[0,i)`房间，产生的总金额
  - 初始化时，`f[0]=0`,因为往前多放了一个点，这个点没什么意义，`f[1]=nums[0]`，偷了第1个房间所产生的收益
  - 状态转移：`f[i]`表示偷了第`i`个房间产生的收益，要看其前1个房间，即不能偷前1个房间，即`f[i-1]`,和前前1个房间，即`f[i-2]`，加上偷了第`i`个房间产生的收益，即`f[i]=max{f[i-1],f[i-2]+nums[i-1]}`,代码如下：

![image-20220305201642897](/Users/frankcooper/Library/Application Support/typora-user-images/image-20220305201642897.png)

```java
        public int rob(int[] nums) {
            int n = nums.length;
            if (n == 0) return 0;
            int[] f = new int[n + 1];
            f[0] = 0;
            f[1] = nums[0];
            for (int i = 2; i <= n; i++) {
                f[i] = Math.max(f[i - 1], f[i - 2] + nums[i - 1]);
            }
            return f[n];
        }
```

- 进而，我们其实发现，虽然上面的一维的空间优化很好了，但是发现在使用的时候，只用到了当前房间，前一个房间，前前一个房间，这几个变量，优化如下：

```java
        public int rob(int[] nums) {
            //到达前一个房间时，获得的最大收益
            int prev = 0;
            int cur = 0;
            for (int x : nums) {
                //max{前一个房间收益，前前一个房间收益+当前房间价值}
                int t = Math.max(cur, prev + x);
                //滚动
                prev = cur;
                cur = t;
            }
            return cur;
        }
```

## 打家劫舍II

```java
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 

示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：

输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：

输入：nums = [1,2,3]
输出：3


提示：

1 <= nums.length <= 100
0 <= nums[i] <= 1000
```

### 分析

> 本题区别于「**打家劫舍I**」是，第一间房间和最后一间房间是连着的，也就是头尾相连，「这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。」

























## 



