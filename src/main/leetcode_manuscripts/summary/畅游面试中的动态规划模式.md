# 畅游面试中的动态规划套路

## 写在前面的话

- 本文链接：[畅游面试中的动态规划套路](https://blog.csdn.net/wat1r/article/details/114377702)

> 本文主题是讲动态规划，涉及题目近40题，每题超过3种方法解决，共100多种写法，思路和目录结构来源于收藏夹中的一个课程[Grokking Dynamic Programming Patterns for Coding Interviews](https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews),其中grok是深刻领会，深入掌握的意思，我翻译成**畅游**，加上自己的理解，消化(截取的课程的目录)，得到本文，文章很长，其实人生的路也很长，是吧？

## 0.什么是动态规划

> 动态规划(DP)是一种求解优化问题的算法，它将问题分解为更简单的子问题，并利用整体问题的最优解取决于子问题的最优解这一事实

看个例子**斐波那契数列**，众所周知，斐波那契数列是一系列的数字，其中每个数字都是前面两个数字的和，前几个斐波那契数列是0、1、1、2、3、5和8，以此类推。
如果我们要求计算第n个斐波那契数列，我们可以用下面的方程来做：

```java
Fib(n) = Fib(n-1) + Fib(n-2), for n > 1
```

我们可以清楚地看到，为了解决整个问题(即`Fib(n)`)，我们将其分解为两个更小的子问题(`Fib(n-1)`和`Fib(n-2)`)。这说明我们可以用DP来解决这个问题

### 动态规划的特点

在理解DP问题的不同方法之前，让我们先看看一个问题的哪些特征告诉我们可以应用DP来解决它。

### 1.重叠子问题

子问题是原始问题的更小粒度。如果找到它的解决方案涉及到多次解决相同的子问题，那么任何问题都有重叠的子问题。以斐波那契数列为例，为了找到`fib(4)`，我们需要将其分解为以下子问题:

![image-20210303191922492](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\image-20210303191922492.png)

我们可以清楚地看到重叠的子问题模式，因为`fib(2)`已经计算了两次，`fib(1)`已经计算了三次。

### 2.最优子结构性质

如果它的整体最优解可以由其子问题的最优解构造出来，那么任何问题都具有最优子结构性质。对于斐波那契数列，我们知道

```java
Fib(n) = Fib(n-1) + Fib(n-2)
```

这清楚地表明大小为`n`的问题已经被简化为大小为`n-1`和`n-2`的子问题。因此，斐波那契数具有最优子结构性质。

### 动态规划的方法

> DP问题一般有两种方式去解决

#### 2.1.自顶向下记忆化(Top-down)

在这种方法中，我们试图通过递归地找到较小子问题的解决方案来解决较大的问题。每当我们解决一个子问题时，对子问题的结果缓存起来，这样当它被多次调用时，我们就不会重复地解决它。相反，我们可以只返回保存的结果。这种存储已经解决的子问题的结果的技术叫做**记忆化**。

我们将在斐波那契数列的例子中看到这种技术。首先，让我们看看寻找第`n`个斐波那契数列的非`DP`递归解:

```java
class Fibonacci {

  public int CalculateFibonacci(int n) {
    if(n < 2) return n;
    return CalculateFibonacci(n-1) + CalculateFibonacci(n-2);
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```

> output

```java
5th Fibonacci is ---> 5
6th Fibonacci is ---> 8
7th Fibonacci is ---> 13
```

正如我们上面所看到的，这个问题显示了重叠子问题模式，所以让我们在这里利用记忆。我们可以使用一个数组来存储已经解决的子问题(请参阅高亮显示的行中的更改)。

```java
class Fibonacci {

  public int CalculateFibonacci(int n) {
    int memoize[] = new int[n+1];
    return CalculateFibonacciRecursive(memoize, n);
  }

  public int CalculateFibonacciRecursive(int[] memoize, int n) {
    if(n < 2)
      return n;
    // if we have already solved this subproblem, simply return the result from the cache
    if(memoize[n] != 0)
      return memoize[n];

    memoize[n] = CalculateFibonacciRecursive(memoize, n-1) + CalculateFibonacciRecursive(memoize, n-2);
    return memoize[n];
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```

#### 2.2.自底向上填表(Bottom-up)

**填表**与自顶向下方法相反，避免了递归。在这种方法中，我们**自底向上**地解决问题(即首先解决所有相关的子问题)。这通常通过填充一个`n`维表来完成。根据表中的结果，然后计算顶部/原始问题的解决方案。

**填表**与**记忆化**是相反的，因为在记忆化中，我们解决问题，并维护已经解决的子问题的映射。换句话说，在记忆化中，我们从上到下，也就是说我们先解决最上面的问题(通常递归下来解决子问题)。

让我们将**填表**应用到我们的斐波那契数列的例子中。因为我们知道每个斐波那契数都是前面两个数的和，所以我们可以使用这个事实来填充我们的表。

下面是自底向上动态规划的代码:

```java
class Fibonacci {

  public int CalculateFibonacci(int n) {
    if (n==0) return 0;
    int dp[] = new int[n+1];
    //base cases
    dp[0] = 0;
    dp[1] = 1;
    for(int i=2; i<=n; i++)
      dp[i] = dp[i-1] + dp[i-2];
    return dp[n];
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```

**我们将始终从一个暴力递归解决方案开始，这是开始解决任何DP问题的最佳方式。**一旦我们有了递归的解决方案，我们就会应用**记忆化**和**填表**。

让我们应用这些知识来解决一些常见的DP问题。

## 1.01背包



![jellyfish-1730018_640](C:\Users\wangzhou\Desktop\jellyfish-1730018_640.jpg)



### 01背包问题

考虑到`N`个物品的`weights`和`profits`，我们被要求把这些物品放在一个容量为`C`的背包里。目标是背包中的物品获得最大的`profits`。每个物品只能选择一次，因为物品的数量是有限制的。

让我们以`Merry's`为例，他想在背包里装一些水果以获得最大的`profits`。以下是水果的`weights`和`profits`：

```java
Items: { Apple, Orange, Banana, Melon }
Weights: { 2, 3, 1, 4 }
Profits: { 4, 5, 3, 7 }
Knapsack capacity: 5
```

让我们试着把不同的水果组合放在背包里，使它们的总重量不超过5：

```java
Apple + Orange (total weight 5) => 9 profit
Apple + Banana (total weight 3) => 7 profit
Orange + Banana (total weight 4) => 8 profit
Banana + Melon (total weight 5) => 10 profit
```

这说明**Banana + Melon**是最好的组合，因为有最大的`profits`，而且总重量不超过背包容量。

#### 问题描述

给定两个整数数组来表示`N`个的`weights`和`profits`，我们需要找到这些项的子集，从而使我们获得最大`profits`，使其累积`weights`不超过给定的`C`。每个物品只能选择一次，这意味着我们要么把一个物品放在背包里，要么跳过它。

#### 常规方式

一个基本的暴力解决方案可以是尝试给定物品的所有组合（正如我们上面所做的），允许我们选择`profits`最大且`weights`不超过`C`的物品。以四个物品（A、B、C和D）为例，如下图所示。要尝试所有组合，我们的算法将如下所示：

```java
for each item 'i' 
  create a new set which INCLUDES item 'i' if the total weight does not exceed the capacity, and 
     recursively process the remaining capacity and items
  create a new set WITHOUT item 'i', and recursively process the remaining items 
return the set from the above two sets with higher profit 
```

![image-20210316184455380](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\image-20210316184455380.png)

所有绿色框的总`weights`小于或等于容量（7），所有红色框的重量大于7。我们最好的解决方案是项目[B，D]的总`profits`为22，总`weights`为7。

```java
class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    return this.knapsackRecursive(profits, weights, capacity, 0);
  }

  private int knapsackRecursive(int[] profits, int[] weights, int capacity, int currentIndex) {
    // base checks
    if (capacity <= 0 || currentIndex >= profits.length)
      return 0;

    // recursive call after choosing the element at the currentIndex
    // if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this
    int profit1 = 0;
    if( weights[currentIndex] <= capacity )
        profit1 = profits[currentIndex] + knapsackRecursive(profits, weights,
                capacity - weights[currentIndex], currentIndex + 1);

    // recursive call after excluding the element at the currentIndex
    int profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + 1);

    return Math.max(profit1, profit2);
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

上述算法的时间复杂度是指数级的$O(2^n)$，其中n表示物品总数。这也可以从上面的递归树中得到证实。正如我们所看到的，我们将有总共31个递归调用-通过计算$O(2^n)+O(2^n)-1$，近似等价于$O(2^n)$

空间复杂度为$O(n)$。此空间将用于存储递归堆栈。因为我们的递归算法是以深度优先的方式处理的，这意味着，在任何时候，调用堆栈上的递归调用不能超过`n`个。

让我们直观地绘制递归调用，看看是否有重叠的子问题。如我们所见，在每个递归调用中，`profits`和`weights`数组保持不变，只有容量和`currentIndex`发生变化。为了简单起见，让我们用`c`表示容量，用`i`表示`currentIndex`：

![image-20210316185940528](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\image-20210316185940528.png)

可以清楚地看到`c:4，i=3`被调用了两次；因此有一个重叠的子问题模式。如上所述，重叠的子问题可以通过记忆化来解决。

#### 自顶向下记忆化动态规划

可以用记忆化来避免重叠的子问题。要重申，记忆化是当我们存储所有先前解决的子问题的结果，并返回内存中的结果。

由于递归函数`knapsackRecursive()`中有两个变量（`capacity`和`currentIndex`），所以可以使用二维数组来存储所有已解决子问题的结果。如上所述，需要为每个子数组（即，对于每个可能的索引`i`）和每个可能的容量`c`存储结果。

```java
class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    Integer[][] dp = new Integer[profits.length][capacity + 1];
    return this.knapsackRecursive(dp, profits, weights, capacity, 0);
  }

  private int knapsackRecursive(Integer[][] dp, int[] profits, int[] weights, int capacity,
      int currentIndex) {

    // base checks
    if (capacity <= 0 || currentIndex >= profits.length)
      return 0;

    // if we have already solved a similar problem, return the result from memory
    if(dp[currentIndex][capacity] != null)
      return dp[currentIndex][capacity];

    // recursive call after choosing the element at the currentIndex
    // if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this
    int profit1 = 0;
    if( weights[currentIndex] <= capacity )
        profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights,
                capacity - weights[currentIndex], currentIndex + 1);

    // recursive call after excluding the element at the currentIndex
    int profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + 1);

    dp[currentIndex][capacity] = Math.max(profit1, profit2);
    return dp[currentIndex][capacity];
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

**时间复杂度和空间复杂度如何** : 因为记忆化的数组`dp[profits.length][capacity+1]`存储所有子问题的结果，可以得出这样的结论：我们不会有超过`N*C`的子问题（其中`N`是物品数量，`C`是背包容量）。这意味着时间复杂度将是$O(N*C)$。

因为用到了数组，空间复杂度是$O(N*C)$，除此之外，用到了$O(N)$的空间做递归栈使用，总的空间是$O(N*C+C)$ 近似于$O(N*C)$

#### 自底向上动态规划

以自底向上的方式，尝试从上面的解决方案填充`dp[][]`数组。本质上，我们希望找到每个子数组和每个可能容量的最大`profits`。这意味着，`dp[i][c]`将代表从第一个`i`物品，容量为`c`的最大背包`profits`。

因此，对于索引`‘i’ (0 <= i < items.length) `处的每个物品和容量`c（0<=c<=capacity）`，有两个选项：

1.不选`i`物品，获取的是子数组排除掉`i`物品的`profits`  `dp[i-1][c]`

2.选`i`物品，获取的是当前`i`物品的价值，和扣除掉`i`物品后的`profits`  `profits[i]+dp[i-1][c-weights[i]]`

最后，最优解将是上述两个值的最大值:

```java
 dp[i][c] = max (dp[i-1][c], profits[i] + dp[i-1][c-weights[i]]) 
```



```java
class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    // basic checks
    if (capacity <= 0 || profits.length == 0 || weights.length != profits.length)
      return 0;

    int n = profits.length;
    int[][] dp = new int[n][capacity + 1];

    // populate the capacity=0 columns, with '0' capacity we have '0' profit
    for(int i=0; i < n; i++)
      dp[i][0] = 0;

    // if we have only one weight, we will take it if it is not more than the capacity
    for(int c=0; c <= capacity; c++) {
      if(weights[0] <= c)
        dp[0][c] = profits[0];
    }

    // process all sub-arrays for all the capacities
    for(int i=1; i < n; i++) {
      for(int c=1; c <= capacity; c++) {
        int profit1= 0, profit2 = 0;
        // include the item, if it is not more than the capacity
        if(weights[i] <= c)
          profit1 = profits[i] + dp[i-1][c-weights[i]];
        // exclude the item
        profit2 = dp[i-1][c];
        // take maximum
        dp[i][c] = Math.max(profit1, profit2);
      }
    }

    // maximum profit will be at the bottom-right corner.
    return dp[n-1][capacity];
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

时间复杂度和空间复杂度都是$O(N*C)$(其中`N`是物品数量，`C`是背包容量)

#### 如何找到已选择的物品

我们知道最终`profits`在右下角，因此，我们将从那里开始寻找背包中的物品。

在每一步中，我们都有两个选项：选或不选。如果不选，那么我们从剩余的物品中获取利润（即，从它正上方的单元格）；如果选，那么我们跳转到剩余的利润以查找更多的物品。

让我们从上面的例子来理解这一点：

![image-20210316194512922](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\image-20210316194512922.png)



1.`22`不是来自顶部单元格（即17），因此我们必须在索引`3`中选此物品（即`D`）。

2.从`22`中减去`D`的利润，得到剩余的利润`6`。然后我们跳到同一行的利润`6`。

3.`6`来自最上面的单元格，所以我们跳到`2`行。

4.同样，`6`来自最上面的单元格，所以我们跳到`1`行。

5.`6`与顶部单元格不同，因此必须包含此物品（即`B`）。

6.从`6`中减去`B`的利润得到利润`0`。然后跳到同一行的利润`0`。一旦剩余利润为零，我们就可以完成商品搜索。

所以进入背包的物品是{B，D}。

> 打印出这些选择的物品

```java
import java.util.*;

class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    // base checks
    if (capacity <= 0 || profits.length == 0 || weights.length != profits.length)
      return 0;

    int n = profits.length;
    int[][] dp = new int[n][capacity + 1];

    // populate the capacity=0 columns, with '0' capacity we have '0' profit
    for(int i=0; i < n; i++)
      dp[i][0] = 0;

    // if we have only one weight, we will take it if it is not more than the capacity
    for(int c=0; c <= capacity; c++) {
      if(weights[0] <= c)
        dp[0][c] = profits[0];
    }

    // process all sub-arrays for all the capacities
    for(int i=1; i < n; i++) {
      for(int c=1; c <= capacity; c++) {
        int profit1= 0, profit2 = 0;
        // include the item, if it is not more than the capacity
        if(weights[i] <= c)
          profit1 = profits[i] + dp[i-1][c-weights[i]];
        // exclude the item
        profit2 = dp[i-1][c];
        // take maximum
        dp[i][c] = Math.max(profit1, profit2);
      }
    }

    printSelectedElements(dp, weights, profits, capacity);
    // maximum profit will be at the bottom-right corner.
    return dp[n-1][capacity];
  }

 private void printSelectedElements(int dp[][], int[] weights, int[] profits, int capacity){
   System.out.print("Selected weights:");
   int totalProfit = dp[weights.length-1][capacity];
   for(int i=weights.length-1; i > 0; i--) {
     if(totalProfit != dp[i-1][capacity]) {
       System.out.print(" " + weights[i]);
       capacity -= weights[i];
       totalProfit -= profits[i];
     }
   }

   if(totalProfit != 0)
     System.out.print(" " + weights[0]);
   System.out.println("");
 }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    Syst
        em.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

空间复杂度`O(1)`的做法



### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

题目链接：[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

题解链接：[畅游面试中的动态规划套路-01背包问题之分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-2f6y/)

#### 方法1:自顶向下记忆化递归(Top-down)

```java
Map<String, Boolean> cache = new HashMap<>();

public boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) sum += num;
    if (sum % 2 != 0) return false;
    sum /= 2;
    return dfs(nums, 0, sum);
}


private boolean dfs(int[] nums, int idx, int target) {
    // System.out.printf("%d\n",idx);
    if (target < 0 || idx >= nums.length) return false;
    if (target == 0) return true;
    String key = idx + "#" + target;
    if (cache.containsKey(key)) return cache.get(key);
    //选与不选
    boolean res = dfs(nums, idx + 1, target - nums[idx]) || dfs(nums, idx + 1, target);
    cache.put(key, res);
    return res;
}
```

#### 方法2：自底向上填表DP(Bottom-up)-朴素版DP

- `dp[N][T+1]`,其中`N`是子集数组的大小，`T`是目标和，多放一个，从0开始的

- `dp[i][j]`表示在子集数组的区间范围内`[0...i]`之间选择若干个数，可以组成`j`
  - 当`j=0`的时候，`dp[i][0]`为`true`，当不选任何子集数组的数的时候，可以形成一种方案
  - 当`i=0`的时候，`dp[0][j]` 指的是当选第0个数的时候，能否等于`j`，显然在`nums[0]=j`的时候满足这种条件，其他都为`false`
- 一般情况，`dp[i][j]`对于，第`i`个数，有这两种情况:
  - 当`j>=nums[i]`的时候，说明`j`还可以拆解,可以选或者不选`i`这个数，只要有一种方案是`true`即可
    - 不选：`dp[i][j]= dp[i-1][j]`
    - 选:`dp[i][j]=dp[i-1][j-nums[i]]`
  - 当`j<nums[i]`的时候，说明`j`不可以拆解，我们肯定选不到`i`这个数了，也就是`dp[i][j]=dp[i-1][j]` 

总结就是：

$$dp[i][j]=
\begin{cases}
dp[i-1][j]||dp[i-1][j-nums[i]]& \text{j>=nums[i]}\\
dp[i-1][j]& \text{j<nums[i]}
\end{cases}$$

- `dp[N-1][T]`即答案

```java
        public boolean canPartition(int[] nums) {
            int N = nums.length;
            int sum = 0;
            for (int i : nums) sum += i;
            if (sum % 2 == 1) return false;
            int T = sum / 2;
            boolean[][] dp = new boolean[N][T + 1];
            for (int i = 0; i < N; i++) dp[i][0] = true;
            for (int j = 0; j <= T; j++) if (j == nums[0]) dp[0][j] = true;
            for (int i = 1; i < N; i++) {
                for (int j = 1; j <= T; j++) {
                    dp[i][j] = dp[i - 1][j];
                    if (j >= nums[i]) dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }
//            PrintUtils.printMatrix(dp);
            return dp[N - 1][T];
        }
```

> 打印

```java
[1,5,11,5]
	   0    1    2    3    4    5    6    7    8    9   10   11
0(1)   T    T    F    F    F    F    F    F    F    F    F    F 
1(5)   T    T    F    F    F    T    T    F    F    F    F    F 
2(11)  T    T    F    F    F    T    T    F    F    F    F    T 
3(5)   T    T    F    F    F    T    T    F    F    F    T    T 
```

`dp[3][11]`往上走到`dp[2][11]` 这一行用掉11 得到11-11 =0 结束

`dp[3][11]`往左走到`dp[3][6]`,这一行用掉5 得11-5 = 6 `dp[3][6]`一直往上走到`dp[1][6]`减去这一行的5  得到 6 -5 =1  到`dp[1][1]` 一直往上走到`dp[0][1]`  减去这一行的1 1-1 =0 结束  5 5 1 是形成11的一个组合

#### 方法3：自底向上填表DP(Bottom-up)-空间压缩O(1)DP

```java
        public boolean canPartition(int[] nums) {
            int N = nums.length;
            int sum = 0;
            for (int i : nums) sum += i;
            if (sum % 2 == 1) return false;
            int T = sum / 2;
            boolean[] dp = new boolean[T + 1];
            dp[0] = true;
            for (int num : nums) {
/*                for (int j = T; j >= 0; j--) {
                    if (j >= num) dp[j] = dp[j] || dp[j - num];
                }*/
                for (int j = T; j >= num; j--) {
                    dp[j] = dp[j] || dp[j - num];
                }

            }
//            PrintUtils.printMatrix(dp);
            return dp[T];
        }
```

关于倒序的遍历的问题：参考这篇：[背包问题之 01 背包问题（科普文，基础，背包九讲）](https://leetcode-cn.com/problems/coin-change/solution/bei-bao-wen-ti-zhi-01bei-bao-wen-ti-ke-pu-wen-ji-c/)











### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

题目链接：[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

题解链接：[畅游面试中的动态规划套路-01背包问题之目标和](https://leetcode-cn.com/problems/target-sum/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-wlxz/)

#### 方法1:暴力递归

```java
        int target;
        int res = 0;

        public int findTargetSumWays(int[] nums, int target) {
            this.target = target;
            dfs(nums, 0, 0);
            return res;
        }

        /***
         * 遍历到idx，对于idx，有两种选择，一种是取+ 一种是取-
         * @param nums 数组
         * @param idx 当前数组遍历的到的位置
         * @param sum 当前已经获得的和
         */
        private void dfs(int[] nums, int idx, int sum) {
            //当idx到达数组末尾
            if (idx == nums.length) {
                if (sum == target) res++;//和正好相等，答案+1
                return;
            }
            dfs(nums, idx + 1, sum + nums[idx]);
            dfs(nums, idx + 1, sum - nums[idx]);
        }
```

#### 方法2:自顶向下记忆化递归(Top-down)

- 做Key的方式比较少见，两个元素一起做组合Key

```java
        int target;
        HashMap<Map<Integer, Integer>, Integer> cache = new HashMap<>();

        public int findTargetSumWays(int[] nums, int target) {
            this.target = target;
            return dfs(nums, 0, 0);
        }

        /***
         * 遍历到idx，对于idx，有两种选择，一种是取+ 一种是取-
         * 返回的是对于idx sum 这组合的key，符合条件的组合数量
         * @param nums 数组
         * @param idx 当前数组遍历的到的位置
         * @param sum 当前已经获得的和
         */
        private int dfs(int[] nums, int idx, int sum) {
            //当idx到达数组末尾
            Map<Integer, Integer> key = new HashMap<Integer, Integer>() {{
                put(idx, sum);
            }};
            if (cache.containsKey(key)) {
                return cache.get(key);
            }
            if (idx == nums.length) {
                if (sum == target) return 1;//和正好相等，答案+1
                return 0;
            }
            int positive = dfs(nums, idx + 1, sum + nums[idx]);
            int negative = dfs(nums, idx + 1, sum - nums[idx]);
            int value = positive + negative;
            cache.put(key, value);
           return value;
        }
```

#### 方法3:自底向上填表DP(Bottom-up)-朴素版

- 将`nums`的元素分成两部分：
  - `a`:所有符号为`+`的和
  - `b`:所有符号为`-`的和

```
taget = a+(-b)
sum   = a+ b   sum为nums的累加和
合并得到
a = (target+sum)/2
```

要求的是`f[n][a]` 在`n`个数中，凑成`a`的结果的组合个数

- 几个特判的`case`:
  - 当目标和`target>sum`的时候，`nums`,题目中给出的数据范围`0 <= nums[i] <= 1000`, 所有的数都是正整数，即所有前置符号都是`+`,换成`-`只会让`sum`结果变小，找不到方案数
  - 上面的等式所得到的结果`a`要求是整除的，即非整除找到方案数

```java
        public int findTargetSumWays(int[] nums, int target) {
            int n = nums.length;
            int sum = 0;
            for (int x : nums) sum += x;
            if (target > sum || (sum + target) % 2 == 1) return 0;
            int W = (sum + target) / 2;
            int[][] f = new int[n + 1][W + 1];//[0..i]中能组成j的方案的数量
            f[0][0] = 1;//[0..0]中能形成0的方案数量，即不选 此为一种方案数量
            for (int i = 1; i <= n; i++) {
                for (int j = 0; j <= W; j++) {
                    if (j >= nums[i - 1]) {//目标数是j 对于当前[i-1]这个元素，可以选，也可以不选，即两者方案数的和
                        f[i][j] = f[i - 1][j] + f[i - 1][j - nums[i - 1]];
                    } else {//选了的话 j -nums[i-1]变成负数，不符合
                        f[i][j] = f[i - 1][j];
                    }
                }
            }
            return f[n][W];
        }
```

#### 方法4:自底向上填表DP(Bottom-up)-空间优化

- 注意倒序遍历

```java
      public int findTargetSumWays(int[] nums, int target) {
            int n = nums.length;
            int sum = 0;
            for (int x : nums) sum += x;
            if (target > sum || (sum + target) % 2 == 1) return 0;
            int W = (sum + target) / 2;
            int[] f = new int[W + 1];
            f[0] = 1;
            for (int i = 1; i <= n; i++) {
                for (int j = W; j >= nums[i - 1]; --j) {
                    f[j] += f[j - nums[i - 1]];
                }
            }
            return f[W];
        }
```



### 01背包问题之一和零

题目链接：[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

题解链接：[畅游面试中的动态规划套路-01背包问题之01背包问题之一和零](https://leetcode-cn.com/problems/ones-and-zeroes/solution/01bei-bao-wen-ti-zhi-yi-he-ling-by-a-fei-8/)

#### 方法1:暴力递归

- TLE

```java
        public int findMaxForm(String[] strs, int m, int n) {
            return helper(strs, strs.length - 1, m, n);
        }


        /**
         * 当前[0....idx]范围内，i个0 j 个1能拼出的字符串的数量，即个数
         *
         * @param strs
         * @param idx
         * @param i
         * @param j
         * @return
         */
        private int helper(String[] strs, int idx, int i, int j) {
            if (idx < 0) return 0;
            int[] t = count(strs[idx]);
            int zeros = t[0], ones = t[1];//当前字符0 和 1 的数量
            if (i >= zeros && j >= ones)
                return Math.max(helper(strs, idx - 1, i, j),
                        helper(strs, idx - 1, i - zeros, j - ones) + 1);
            else return helper(strs, idx - 1, i, j);

        }


        private int[] count(String s) {
            int[] res = new int[2];
            for (char c : s.toCharArray()) res[c - '0']++;
            return res;
        }
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
 Integer[][][] cache;//cache[k][i][j] 表示[0..k-1]范围内的字符，在i个0 j个1的条件下，能拼出的字符串的数量，即个数


        public int findMaxForm(String[] strs, int m, int n) {
            cache = new Integer[strs.length][m + 1][n + 1];
            return helper(strs, strs.length - 1, m, n);
        }


        /**
         * 当前[0....idx]范围内，i个0 j 个1能拼出的字符串的数量，即个数
         *
         * @param strs
         * @param idx
         * @param i
         * @param j
         * @return
         */
        private int helper(String[] strs, int idx, int i, int j) {
            if (idx < 0) return 0;//这一句要放在返回cache结果前面，因为idx是数组下标索引，可能为-1
            if (cache[idx][i][j] != null) return cache[idx][i][j];
            int[] t = count(strs[idx]);
            int zeros = t[0], ones = t[1];//当前字符0 和 1 的数量
            if (i >= zeros && j >= ones)
                cache[idx][i][j] = Math.max(helper(strs, idx - 1, i, j),
                        helper(strs, idx - 1, i - zeros, j - ones) + 1);
            else cache[idx][i][j] = helper(strs, idx - 1, i, j);
            return cache[idx][i][j];

        }


        private int[] count(String s) {
            int[] res = new int[2];
            for (char c : s.toCharArray()) res[c - '0']++;
            return res;
        }
```



#### 方法3:自底向上填表DP(Bottom-up)-朴素版



> 类比于01背包问题，在选择第k个字符串时，即strs[k-1]，有两个选择，选和不选，不选的话，数量等于之前遍历过的最大值，选的话，我们需要考虑背包容量的问题，但本题有点不一样的是，背包容量有两个限制条件，目前的0和1的数量，都需要在减去当前这个字符strs[k-1]，被选中的情况下，还有0和1，数量需要大于等于0

#### 定义状态

```java
int[][][] dp = new int[len + 1][m + 1][n + 1];
//len是字符数组的个数，m相当于背包容量0的个数，n相当于背包容量1的个数
//要求的是dp[k][m][n]，即第k个字符strs[k-1]，一路走来，m个0，和n个1全部消耗掉，能拼出的字符串的数量，即个数
```

**$dp[k][i][j]$ 表示遍历到第$k-1$个字符的时候，使用$i$个0，$j$个1的时候，能够拼出的字符串的数量，即个数**

#### 转移方程




$$dp[k][i][j]= \begin{cases} 1+dp[k-1][i-cost\_zero[k]][j-cost\_one[k]]& \text{ i>=cost\_zero[k] and j>=cost\_one[k]}\\ dp[k-1][i][j]& \text{  } \end{cases}$$ 













### 盈利计划

![image-20200918081921253](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\pack\Untitled.assets\image-20200918081921253.png)

#### 方法1:暴力递归

见方法2

#### 方法2:自顶向下记忆化递归(Top-down)

```java
   static int MOD = (int) (1e9 + 7);
        Long[][][] cache;


        public int profitableSchemes(int G, int P, int[] group, int[] profit) {
            int M = group.length;//group数组的长度
            cache = new Long[M + 1][G + 1][P + 1];
            return (int) dfs(0, G, P, group, profit);
        }

        /**
         * @param idx    当前处理到group数组的下标索引
         * @param G      员工的数量
         * @param P      至少产生的利润
         * @param group  利润需要的员工数量数组
         * @param profit 工作产生的利润数组
         * @return 当前条件下产生的利润下的方案数量
         */
        private long dfs(int idx, int G, int P, int[] group, int[] profit) {
            if (idx >= group.length) {
                if (P <= 0) return 1;//获取利润0的方案数，认为是1一种方案
                else return 0;//否则，idx越界了，方案数是0
            }
            long res = 0;
            if (cache[idx][G][P] != null) return cache[idx][G][P];
            if (G >= group[idx]) {
                res += dfs(idx + 1, G - group[idx], Math.max(P - profit[idx], 0), group, profit);
            }
            res += dfs(idx + 1, G, P, group, profit);
            res %= MOD;
            cache[idx][G][P] = res;
            return res;
        }
```



另外一种写法(索引从大到小枚举)：

```java
  static int MOD = (int) (1e9 + 7);
        Long[][][] cache;


        public int profitableSchemes(int G, int P, int[] group, int[] profit) {
            int M = group.length;//group数组的长度
            cache = new Long[M + 1][G + 1][P + 1];
            return (int) dfs(M - 1, G, P, group, profit);
        }

        /**
         * @param idx    当前处理到group数组的下标索引
         * @param G      员工的数量
         * @param P      至少产生的利润
         * @param group  利润需要的员工数量数组
         * @param profit 工作产生的利润数组
         * @return 当前条件下产生的利润下的方案数量
         */
        private long dfs(int idx, int G, int P, int[] group, int[] profit) {
            if (idx <0) {
                if (P <= 0) return 1;//获取利润0的方案数，认为是1一种方案
                else return 0;//否则，idx越界了，方案数是0
            }
            long res = 0;
            if (cache[idx][G][P] != null) return cache[idx][G][P];
            if (G >= group[idx]) {
                res += dfs(idx - 1, G - group[idx], Math.max(P - profit[idx], 0), group, profit);
            }
            res += dfs(idx - 1, G, P, group, profit);
            res %= MOD;
            cache[idx][G][P] = res;
            return res;

```

#### 方法3:自底向上填表DP(Bottom-up)-朴素版DP

##### 定义状态

$dp[i][j][k]$表示:

- 当处理到前$i$个利润$profit$的情况下（即$profit[0...i-1]$）
- 当前可用的团队成员在可以上探到$j$名的情况下(即$group[0...j-1]$)
- 能获取到的利润至少为$k$

在同时满足上述三个条件下的方案数量

##### 转移方程

考虑当前状态$dp[i][j][k]$，需要考虑之前的状态，如果我们考虑$dp[i-1][j][k]$这个状态，这个状态表示什么呢？

>$dp[i-1][j][k]$表示:
>
>- 当处理到前$i-1$个利润$profit$的情况下（即$profit[0...i-2]$）
>- 当前可用的团队成员在可以上探到$j$名的情况下(即$group[0...j-1]$)
>- 能获取到的利润至少为$k$
>
>在同时满足上述三个条件下的方案数量

而从$dp[i-1][j][k]$怎么滑向$dp[i][j][k]$这个状态的呢？其实是因为在$i$这个利润（$profit[i-1]$），没有选择要，也就是说没有犯罪，这样才出现了团队成员从上一个状态滑过来的时候，没有减少，继续为$j$,获取的利润也未有变化，继续为$k$

那如果我们选择要了这个利润呢($profit[i-1]$)？

那么$dp[i][j][k]$之前的状态是$dp[i-1][j-group[i-1]][k-profit[i-1]]$

因为上面的是各自得到的方案数量，需要全部的方案返回：

最终的动态转移方程:

$dp[i][j][k]$=$dp[i-1][j][k]$+$dp[i-1][j-group[i-1]][k-profit[i-1]]$

根据上面的转移方程，因为每个维度的下标索引不能小于$0$

所以:

- $i-1$>=$0$  但是$i$这个维度的上限是$N$名个利润，也就是$profit$数组的大小
- $j-group[i-1]$>=0  但是$j$这个维度的上限是$G$名成员
- $k-profit[i-1]$>=0  但是$k$这个维度的上限是$P$的利润

##### 边界

考虑$dp[i][j][0]$：

> $dp[i][j][0]$表示:
>
> - 当处理到前$i-1$个利润$profit$的情况下（即$profit[0...i-1]$）
> - 当前可用的团队成员在可以上探到$j$名的情况下(即$group[0...j-1]$)
> - 能获取到的利润至少为$0$
>
> 在同时满足上述三个条件下的方案数量
>
> 这个数量，可以想象成一开始进入这个状态，我就有0元，可以理解为1种方案数量

##### 主体代码

```java
    int MOD = 1_000_000_007;

    public int profitableSchemes(int G, int P, int[] group, int[] profit) {
        int N = profit.length;
        int[][][] dp = new int[N + 1][G + 1][P + 1];
        //初始化
        for (int i = 0; i <= N; ++i) {
            for (int j = 0; j <= G; ++j) {
                dp[i][j][0] = 1;
            }
        }
        //三层dp循环
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= G; ++j) {
                for (int k = 0; k <= P; ++k) {
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (j >= group[i - 1]) {
                        //nk 表示new k 小于0 没有意义
                        int nk = Math.max(k - profit[i - 1], 0);
                        dp[i][j][k] += dp[i - 1][j - group[i - 1]][nk];
                    }
                    dp[i][j][k] %= MOD;
                }
            }
        }
        //最终返回
        return dp[N][G][P];
    }
```

#### 方法4:自底向上填表DP(Bottom-up)-朴素版`DP` 

> `dp[i][j][k]`
>
> - 当处理到前$i$个利润$profit$的情况下（即$profit[0...i-1]$）
> - 当前可用的团队成员在只有$j$名的情况下(即$group[0...j-1]$)
> - 能获取到的利润至少为$k$
>
> 在同时满足上述三个条件下的方案数量

```java
G = 5 //表示5名员工
P= 3 //表示最小利润 
group ={2,2} //第i个工作获取的利润
profit={2,3} //第i个工作需要的员工数量

//下面的是方法2，的填表，三维，最后的结是sum的 也就是打了# # 之前的数字sum起来
dp[i][j][k]

i:0
  1   0   0   0 
  0   0   0   0 
  0   0   0   0 
  0   0   0   0 
  0   0   0   0 
  0   0   0   0 

i:1
  1   0   0   0 
  0   0   0   0 
  1   1   1   0 
  0   0   0   0 
  0   0   0   0 
  0   0   0   0 

i:2
  1   0   0   #0# 
  0   0   0   #0# 
  2   2   2   #1# 
  0   0   0   #0# 
  1   1   1   #1# 
  0   0   0   #0#  
for (int j = 0; j <= G; j++) {
    System.out.printf("i:%d,j:%d,k:%d\n", N, j, P);
    sum = (sum + dp[N][j][P]) % MOD;
}
//N = 2 ，P= 3  j可以从0到5 
 dp[2][0][3] = 0 //表示在获取利润数组 {2,3}， 获得最少的例如 P=3的情况下，使用0名工人 的方案数量
 dp[2][2][3] = 1 //表示在获取利润数组 {2,2}， 获得最少的例如 P=3的情况下，使用2名工人 的方案数量
     
     
//下面是方法1 不使用sum的情况下直接返回   dp[N][G][P]  其实就是 # # 圈起来的数
i:0
  1   0   0   0 
  1   0   0   0 
  1   0   0   0 
  1   0   0   0 
  1   0   0   0 
  1   0   0   0 

i:1
  1   0   0   0 
  1   0   0   0 
  2   1   1   0 
  2   1   1   0 
  2   1   1   0 
  2   1   1   0 

i:2
  1   0   0   0 
  1   0   0   0 
  3   2   2   1 
  3   2   2   1 
  4   3   3   2 
  4   3   3   #2# 
//比较两个不同，大概就是sum的，工人固定了数量（方法2） 非sum的 （方法1） 满状态是当前的工人的数量，可以减工人数量
```



```java
 int MOD = 1_000_000_007;


    public int profitableSchemes(int G, int P, int[] group, int[] profit) {
        int N = profit.length;
        int[][][] dp = new int[N + 1][G + 1][P + 1];
        //初始化
        dp[0][0][0] = 1;
        //三层dp循环
        for (int i = 1; i <= N; ++i) {
            for (int j = 0; j <= G; ++j) {
                for (int k = 0; k <= P; ++k) {
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (j >= group[i - 1]) {
                        //nk 表示new k 小于0 没有意义
                        int nk = Math.max(k - profit[i - 1], 0);
                        dp[i][j][k] += dp[i - 1][j - group[i - 1]][nk];
                    }
                    dp[i][j][k] %= MOD;
                }
            }
        }
        //最终返回
        int sum = 0;
        for (int i = 0; i <= G; i++) {
            sum = (sum + dp[group.length][i][P]) % MOD;
        }
        return sum;
    }
```

#### 方法5::自底向上填表DP(Bottom-up)-压缩版DP

- $i$这个状态依赖$i-1$去掉这个状态，滚动

```java
int G = 5;
int P = 3;
int[] group = new int[]{2, 2};
int[] profit = new int[]{2, 3};
--------------
  1   0   0   0 
  0   0   0   0 
  2   2   2   1 
  0   0   0   0 
  1   1   1   1 
  0   0   0   0 
--------------
```



```java
    int MOD = 1_000_000_007;


    public int profitableSchemes(int G, int P, int[] group, int[] profit) {

        int N = profit.length;
        int[][] dp = new int[G + 1][P + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= N; ++i) {
            int g = group[i - 1];
            int p = profit[i - 1];
            for (int j = G; j >= g; j--) {
                for (int k = P; k >= 0; k--) {
                    int nk = Math.max(k - p, 0);
                    dp[j][k] = (dp[j][k] + dp[j - g][nk]) % MOD;
                }
            }
        }
        //获取到至少P利润下的结果，因为上述中k取得是P的上限，往下探的
        int sum = 0;
        for (int i = 0; i <= G; i++) {
            sum = (sum + dp[i][P]) % MOD;
        }
        return sum;
    }
```

### 01背包问题之最后一块石头的重量[Pelican]

题目链接：[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

题解链接：[畅游面试中的动态规划套路-01背包问题之01背包问题之最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight-ii/solution/dong-tai-gui-hua-jie-zui-hou-yi-kuai-shi-tou-de-zh/)

#### 方法1:暴力递归

- 代码见方法2

#### 方法2:自顶向下记忆化递归(Top-down)

- 处理方式和494题很类似

```java
HashMap<Map<Integer, Integer>, Integer> cache = new HashMap<>();

        public int lastStoneWeightII(int[] stones) {
            dfs(stones, 0, 0);
            Map<Integer, Integer> key = new HashMap<Integer, Integer>() {{
                put(0, 0);
            }};
            return cache.get(key);

        }


        private int dfs(int[] stones, int idx, int sum) {
            //当idx到达数组末尾
            Map<Integer, Integer> key = new HashMap<Integer, Integer>() {{
                put(idx, sum);
            }};
            if (cache.containsKey(key)) {
                return cache.get(key);
            }
            if (idx == stones.length) {
                return sum >= 0 ? sum : Integer.MAX_VALUE;
            }
            int positive = dfs(stones, idx + 1, sum + stones[idx]);
            int negative = dfs(stones, idx + 1, sum - stones[idx]);
            int value = Math.min(positive, negative);
            cache.put(key, value);
            return value;
        }
```

#### 方法3:自底向上填表DP(Bottom-up)-朴素版

#### 思路

将$stones$的总和分成两堆

- 当两堆的数量恰好相等，每个堆的石头的数量恰好是$sum/2$($sum$是偶数)，这两堆石头碰撞，想象成正负离子碰撞，稀碎后，剩下$0$，也就是渣
- 当两堆的数量不相等的时候，有堆大，有堆小，但是要尽可能地缩小两个堆的差，拿到那堆数量和小的那堆，做成负离子，然后放进去掉那堆负离子的堆中，正负离子碰撞，剩下的正离子就是要求的，核心点是求出那堆找出若干块石头，似的其种类接近$sum/2$,上限是这个$sum/2$

##### 定义状态

$f(i,j)$表示当遇到第i个物品时，背包容量为j时，能获得的最大价值

来到本题：**$f(i,j)$表示遇到第i个石头时，j的背包容量（初始时从1开始到sum/2结束），能装的石头的重量**

##### 转移方程

对于第i个石头时，有两种决定，选与不选：

- 不选，依赖前一个石头的情况:$f[i-1][j]$
- 选，减去当前的背包的容量，并且加上当前的价值$v[i]$,  得到$f[i-1][j-stone[i-1]]+-stone[i-1]$

注：下标的对应情况，初始化时$f[n+1][sum/2+1]$, 对应的$stones$的下标要相差一位

```java
    public int lastStoneWeightII(int[] stones) {

        int n = stones.length;
        int sum = 0;
        for (int stone : stones) sum += stone;
        int[][] dp = new int[n + 1][sum / 2 + 1];
        for (int i = 1; i <= n; ++i) {
            int currStone = stones[i - 1];
            for (int j = 1; j <= sum / 2; ++j) {
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
                if (j >= currStone) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - currStone] + currStone);
                }
            }
        }
        int res = sum - 2 * dp[n][sum / 2];
        return res;
    }
```

#### 方法4:自底向上填表DP(Bottom-up)-空间压缩优化

```java
    public int lastStoneWeightII(int[] stones) {
        int n = stones.length;
        int sum = 0;
        for (int stone : stones) sum += stone;
        int m = sum / 2;
        int[] dp = new int[m + 1];
        for (int i = 0; i < n; ++i) {
            int currStone = stones[i];
            for (int j = m; j >= currStone; j--) {
                dp[j] = Math.max(dp[j], dp[j - currStone] + currStone);
            }
        }
        int res = sum - 2 * dp[m];
        return res;
    }
```































#### 

















## 2.完全背包

![illustration-1705197_640](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\illustration-1705197_640.jpg)







「力扣」第 518 题：零钱兑换 II（中等）；
「力扣」第 1449 题：数位成本和为目标值的最大数字（困难）。



### Cutting Rod

#### 方法1:暴力递归

- 代码略

#### 方法2:自顶向下记忆化递归(Top-down)

```java
        Integer[][] cache;
        int[] lengths;
        int[] prices;

        public int rodCutting(int[] lengths, int[] prices, int rodlength) {
            this.lengths = lengths;
            this.prices = prices;
            cache = new Integer[lengths.length][rodlength + 1];//
            return helper(rodlength, 0);
        }


        private int helper(int rodlength, int curIdx) {
            if (curIdx >= lengths.length) return 0;
            if (cache[curIdx][rodlength] != null) return cache[curIdx][rodlength];
            int choose = 0;//选
            if (lengths[curIdx] <= rodlength) {
                choose = prices[curIdx] + helper(rodlength - lengths[curIdx], curIdx);
            }
            int non_choose = helper(rodlength, curIdx + 1);//不选
            return cache[curIdx][rodlength] = Math.max(choose, non_choose);
        }
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
     public int rodCutting(int[] lengths, int[] prices, int n) {
            int m = lengths.length;
            int[][] f = new int[m][n + 1];
            for (int i = 0; i < m; i++) {
                for (int j = 1; j <= n; j++) {
                    int choose = 0, non_choose = 0;
                    if (lengths[i] <= j) choose = prices[i] + f[i][j - lengths[i]];
                    if (i > 0) non_choose = f[i - 1][j];
                    f[i][j] = Math.max(choose, non_choose);
                }
            }
            return f[m - 1][n];
        }
```

- 测试

```java
            _2nd handler = new _2nd();
            int[] lengths = {1, 2, 3, 4, 5};//每一根木棒的长度
            int[] prices = {2, 6, 7, 10, 13};//每一根木棒的利润
            int rodlength = 5;
            System.out.println(handler.rodCutting(lengths, prices, rodlength));
```









### [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

题目链接：[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

题解链接：[畅游面试中的动态规划套路-完全背包系列之零钱兑换](https://leetcode-cn.com/problems/coin-change/solution/bei-bao-si-xiang-jie-jue-ling-qian-dui-huan-wen-2/)

#### 零钱兑换问题的Follow Up 1

> Follow Up指的是面试过程中的追问环节，包括但不限于已有问题的举一反三，边界条件，优化方案

![JEty1e.png](https://s1.ax1x.com/2020/04/17/JEty1e.png)

- $base$题是基于这一题：给定不同面额的硬币$ coins$ 和一个总金额 $amount$。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1, 你可以认为**每种硬币的数量是无限的**。 

##### Step 1 零钱兑换问题(01背包)

**题目描述**：给定不同面额的硬币$ coins$ 和一个总金额 $amount$。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1, **但是每个硬币只能选择一次**

##### 题目分析

- 因为提到了**每个硬币只能选择一次**，这个与**[01背包]()**很吻合

---

> 这是01背包的抽象模型

#####  参数定义：

- $N$件物品
- $V$背包的总容量
- $Ci$放入第$i$件物品耗费的费用
- $Wi$放入第$i$件物品得到的价值

##### **定义状态**

$F[i,v]$表示前$i$件物品恰好放入一个容量为$v$的背包可以获得的最大价值

##### 选择

转移方程应为是：$F[i,v]=max(F[i-1,v],F[i-1,v-Ci]+Wi)$

- 解释：将第$i$件物品放入容量为$v$的背包中，只需要基于$i-1$件物品的基础上做第$i$件物品的放与不放的问题
  - 不放入第$i$件物品，获得的最大价值是$F[i-1,v]$
  - 放入第$i$件物品，获得的最大价值是$F[i-1,v-Ci]+Wi$,因为第$i$件物品已经放进去背包了，留给前$i-1$件物品的背包容量只有$v-Ci$,而通过放入第$i$件物品，获取的价值是$Wi$

##### 边界条件

- $dp[0][0]$表示当选择是$0$个物品时，在没有物品，背包体积为$0$时，不装任何东西的时候$dp[0][0]=0$
- $F[i-1,v-Ci]$其中$v>=Ci$，不然为负数，没有意义

---

> 回到本题

##### 定义状态

- $F[i,v]$表示前$i$件物品恰好放入一个容量为$v$的背包可以获得的最大价值，套用到本题即，$dp[i][j]$**表示前$i$个硬币，组成目标金额为$j$的最少硬币数量**。

##### 选择

- 根据上文中的**01背包**的抽象模型，$dp[i][j]$依赖于对于第$i$个硬币**拿与不拿**这两种选择
  - 不拿:$dp[i-1][j]$,相当于前$i-1$个硬币选择，组成目标金额$j$的最少硬币
  - 拿:$dp[i-1][j-coins[i]]+1$，从前$i-1$个硬币选择，组成目标金额$j-coins[i]$，因为拿了第$i$个硬币，所有选择方案上的硬币数量需要$+1$
  - 最终的动态转移方程:$dp[i][j]=min(dp[i-1][j],dp[i-1][j-coins[i]+1])$

##### 边界条件

- $dp[amount+1]$，表示从$0$到$amount$的所有状态，初始化时，全部置为$inf$，为了最后找到有些情况不可达，返回-1的结果
- $dp[0]=0$，组成目标金额为$0$的硬币选择方案，即什么硬币都不选，最少硬币为$0$个

> *只给出了一维数组$dp$版，其他版本可参见底部的阅读*

```python
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins)
        # 初始化数组 dp[amount+1] 为 float('inf')
        dp = [float('inf') for i in range(amount + 1)]
        dp[0] = 0
        for i in range(1, n + 1):
            for j in range(amount, coins[i - 1], -1):
                dp[j] = min(dp[j], dp[j - coins[i]] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1
```

##### Step 2 零钱兑换问题(完全背包)

**题目描述**：给定不同面额的硬币$ coins$ 和一个总金额 $amount$。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1, **每个硬币可以选择无数次**

##### 题目分析

- 因为提到了**每个硬币可以选择无数次**，这个与**[完全背包]()**很吻合

---

> 这是完全背包的抽象模型

##### 参数定义：

- $N$件物品
- $V$背包的总容量
- $Ci$放入第$i$件物品耗费的费用
- $Wi$放入第$i$件物品得到的价值动态规划的几大要素：状态，选择以及边界条件

每件物品可以 取用0件，1件，2件...$V/Ci$件，

##### **定义状态**

- $F[i,v]$表示前$i$个物品恰好放入容量为$v$的背包时获取到的最大价值，很容易得到如下的动态转移方程：
  - $F[i,v]=max(F[i-1,v-kCi]+kWi|kCi∈[0,v])$

##### 边界条件

- 如果创建一个$dp=int[N+1][V+1]$的二维动态数组，当$dp[0][0]$时，表示的时物品数与背包的容量都是$0$的，显然其结果为$0$

---

> 回到本题

- $dp[amount+1]$，初始化$dp[0]=0$,表示欲组成总金额为$0$硬币的最少个数，为$0$,一个硬币都不取
- $dp[j]$:使用$coins$组成目标金额为$j$的最少硬币数量
- 动态转移方程：$dp[j]=min(dp[j],dp[j-coins[i-1]]+1)$ 其中$i-1$表示的是第$i$个硬币

```python
    def change(self, coins: List[int], amount: int) -> int:
        # 初始化数组 dp[amount+1] 为 float('inf')
        dp = [float('inf') for i in range(amount + 1)]
        dp[0] = 0
        for coin in coins:
            for j in range(coin, amount + 1):
                dp[j] = min(dp[j], dp[j - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1
```

##### Step 3 零钱兑换问题(多重背包)

**题目描述**：给定不同面额的硬币$ coins$ 和一个总金额 $amount$，**每个硬币的选择次数有限制，上限$t$次**，编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1

##### 题目分析

- 因为提到了**每个硬币的选择次数有限制，上限$t$次**，这个与**[多重背包]()**很吻合

##### 定义状态

- 对于第$i$中硬币，可以由0 ,1 2.....k 到t 次 的选择，**$dp[i][j]$表示前$i$个硬币组成金额为$j$时的最少硬币数量**

```
dp[i][j] = 
min(dp[i-1]dp[j],
	dp[i-1][j-c]+1, 
	dp[i-1][j-2*c]+2, 
	...,
	dp[i-1][j-k*c]+k)
	其中k∈[1,t]
```

- 代码：

```python
    def change(self, coins: List[int], amount: int, t: List[int]) -> int:
        dp = [float('inf') for i in range(amount + 1)]
        dp[0] = 0
        for i in range(len(coins)):
            for j in range(amount, coins[i] - 1, -1):
                for k in range(1, t[i] + 1): 
                    if j >= k * coins[i]:  
                        dp[j] = min(dp[j], dp[j - k * coins[i]] + k)
        return -1 if dp[amount] > amount else dp[amount]
```



















- 选str[k-1]这个字符时
- 不选str[k-1]这个字符时

其中$cost\_zero[k]$ 和 $cost\_one[k]$,是到达第$k-1$个字符串的时候，这个字符串中0和1的数量，因为数据的下标索引小于0是无意义的

#### 边界

每个维度+1，第0个字符是空字符串

```java
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[][][] dp = new int[len + 1][m + 1][n + 1];
        for (int k = 1; k < len + 1; ++k) {
            int[] counter = counter(strs[k - 1]);
            for (int i = 0; i < m + 1; ++i) {
                for (int j = 0; j < n + 1; ++j) {
                    if (i >= counter[0] && j >= counter[1]) {
                        dp[k][i][j] = Math.max(dp[k][i][j],
                                dp[k - 1][i - counter[0]][j - counter[1]] + 1);
                    }
                    dp[k][i][j] = Math.max(dp[k][i][j], dp[k - 1][i][j]);
                }
            }
        }
        return dp[len][m][n];
    }

    /**
     * 计算str字符串中的 0和1的个数， counter[0] 是 "0"的个数，counter[1]是"1"的个数
     *
     * @param str
     * @return
     */
    public int[] counter(String str) {
        int[] counter = new int[2];
        for (char c : str.toCharArray()) counter[c - '0']++;
        return counter;
    }

```

#### 方法4:自底向上填表DP(Bottom-up)-空间压缩

> 动态规划的几大要素：状态，选择以及边界条件

#####  参数定义：

- $N$件物品
- $V$背包的总容量
- $Ci$放入第$i$件物品耗费的费用
- $Wi$放入第$i$件物品得到的价值

##### **定义状态**

$F[i,v]$表示前$i$件物品恰好放入一个容量为$v$的背包可以获得的最大价值，而转移方程应为是：$F[i,v]=max(F[i-1,v],F[i-1,v-Ci]+Wi)$

- 解释：将第$i$件物品放入容量为$v$的背包中，只需要基于$i-1$件物品的基础上做第$i$件物品的放与不放的问题
  - 不放入第$i$件物品，获得的最大价值是$F[i-1,v]$
  - 放入第$i$件物品，获得的最大价值是$F[i-1,v-Ci]+Wi$,因为第$i$件物品已经放进去背包了，留给前$i-1$件物品的背包容量只有$v-Ci$,而通过放入第$i$件物品，获取的价值是$Wi$

##### 边界条件

- $dp[0][0]$表示当选择是$0$个物品时，在没有物品，背包体积为$0$时，不装任何东西的时候$dp[0][0]=0$
- $F[i-1,v-Ci]$其中$v>=Ci$，不然为负数，没有意义

##### 核心代码

```
dp[N+1][V+1]
dp[0][0...V]=0
dp[0...N][0]=0
for i in range(1,N+1)
	for j in range(1,V+1)
    	dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i])
```

> 上面是01背包的模型

#### 定义状态

**$dp[i][j]$ 表示遍历到第$k$个字符的时候，使用$i$个0，$j$个1的时候，能够拼出的字符串的数量，即个数**

```java
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[][] dp = new int[m + 1][n + 1];
        for (String str : strs) {
            int[] counter = counter(str);
            for (int i = m; i >= counter[0]; i--) {
                for (int j = n; j >= counter[1]; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - counter[0]][j - counter[1]] + 1);
                }
            }
        }
        return dp[m][n];
    }

    /**
     * 计算str字符串中的 0和1的个数， counter[0] 是 "0"的个数，counter[1]是"1"的个数
     *
     * @param str
     * @return
     */
    public int[] counter(String str) {
        int[] counter = new int[2];
        for (char c : str.toCharArray()) counter[c - '0']++;
        return counter;
    }
```



### [零钱兑换II](https://leetcode-cn.com/problems/coin-change/)

题目链接：[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

题解链接：[背包思想解决零钱兑换问题(逐步优化，多方法)](https://leetcode-cn.com/problems/coin-change-2/solution/bei-bao-si-xiang-jie-jue-ling-qian-dui-huan-wen-ti/)

##### 题目分析

- **假设每一种面额的硬币有无限个** 这是题目描述的，符合**完全背包问题**:每件物品可以无限制的取用，只要不超过总的背包容量，把背包撑爆

- 完全背包的抽象模型，参见前文

##### 方法1:朴素版(三层循环)

##### 定义状态

- $dp[i][j]$: $coins[0..i]$范围内的硬币，组成目标金额为$j$，能得到的组合数
- 当遇到一种新的硬币$coins[i]$时，可以选$0$种，$1$种，$2$种，直到$k$种，因为可以对于一种硬币进行无数种选择，只要$j-coins[i-1]≥0$即可，不满足这个条件，背包撑爆，对于这个状态本身没有什么意义，将上面的每个子状态的和累加，即是所求$dp[i][j]$
  - 动态转移方程：$ \sum_{0}^k dp[i-1][j-k*coins[i-1]] $

##### 边界条件

- 多设置一行，$dp=int[n+1][...]$  将$dp[0][0]$置为$1$，其他为$0$

```java
    public int change1st(int amount, int[] coins) {
        int n = coins.length;
        int[][] dp = new int[n + 1][amount + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= amount; j++) {
                for (int k = 0; k * coins[i - 1] <= j; k++) {
                    dp[i][j] += dp[i - 1][j - k * coins[i - 1]];
                }
            }
        }
        return dp[n][amount];
    }
```

##### 复杂度分析

- 时间复杂度：$O(N*amount^2)$其中$N$是硬币的个数即$coins$数组的长度，$amount$是金额
- 空间复杂度：$O(N*amount)$,即$dp$使用的空间

#####  方法2：优化(两层循环)

##### 定义状态

- $dp[i][j]$：$coins[0....i-1]$这前$i$个硬币，组成金额为$j$，能得到的组合数
- $dp[i][j]$依赖于两个状态，选不选$coins[i-1]$这个硬币，
  - 不选的时候为$dp[i-1][j]$,不选$coins[i-1]$时，只能在前$i-1$个硬币中组成$j$
  - 选的时候为$dp[i][j-coins[i-1]]$，选$coins[i-1]$时，总的金额减少到$j-coins[i-1]$,但由于是完全背包问题，每个物品可以选无限次，所以，剩下的可以选的硬币还是应该是$coins[0...i-1]$前$i$个
  - 状态转移方程：$dp[i][j]$=$dp[i-1][j]$+$dp[i][j-coins[i-1]]$，这其中可以做个优化，$j-coins[i-1]<0$的情况无意义，可以过滤

##### 边界条件

- $dp[i][0]$前$i$个硬币形成金额为$0$的组合数，为$1$那就是不选任何硬币，只有这$1$种选法
- $dp[0][j]$其中$j≠0$，前$0$种硬币组成目标金额为$j$的组合数，初始化时，$dp==int[n+1][...]$前$0$种硬币其实是没有硬币的，翻译下来是没有硬币，如何组成$j$，答案显然是$0$
- 注意在初始化$dp[0][j]$时，不要将$dp[0][0]$的状态覆盖掉了

##### 结果

- $dp[n][amount]$前$n$中硬币形成了$amount$的组合数，即$coins[0...n-1]$形成了$amount$

```java
    public int change2nd(int amount, int[] coins) {
    	int n = coins.length;
        int[][] dp = new int[n + 1][amount + 1];
        for (int i = 0; i <= n; i++) dp[i][0] = 1;
        for (int j = 1; j <= amount; j++) dp[0][j] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= amount; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - coins[i - 1] >= 0) dp[i][j] += dp[i][j - coins[i - 1]];
            }
        }
        return dp[n][amount];
    }
```

##### 复杂度分析

- 时间复杂度：$O(N*amount)$其中$N$是硬币的个数即$coins$数组的长度，$amount$是金额
- 空间复杂度：$O(N*amount)$,即$dp$使用的空间

- 相比于**方法1**,优化了一层循环，时间复杂度变好

##### 方法3：优化(一维数组)

##### 定义状态

- 将方法2中的$dp[i][j] =dp[i - 1][j]+ dp[i][j - coins[i - 1]];$去掉一维$i$得到，$dp[j]=dp[j+dp[j-coins[i]]]$这里$i$从$0$开始的，不需要取$coins[i-1]$

##### 边界条件

- 没有硬币时候，不选任何硬币，可以组成金额为$0$，只有这么一种组合，$dp[0]$等价于$dp[0][0]$

```java
 public int change3rd(int amount, int[] coins) {
        int n = coins.length;
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 0; i < n; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] = dp[j] + dp[j - coins[i]];
            }
        }
        return dp
```

##### 复杂度分析

- 时间复杂度：$O(N*amount)$其中$N$是硬币的个数即$coins$数组的长度，$amount$是金额
- 空间复杂度：$O(amount)$,即$dp$使用的空间，将二维降低为一维

















































































































## 3.斐波那契数列

更多内容：

[畅游面试中的动态规划套路](https://blog.csdn.net/wat1r/article/details/114377702)



![watercolour-4799014_640](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\watercolour-4799014_640.jpg)



### 斐波那契数

题目链接：[509. Fibonacci Number](https://leetcode-cn.com/problems/fibonacci-number/)

题解链接：[畅游面试中的动态规划套路-斐波那契数列系列之斐波那契数列](https://leetcode-cn.com/problems/fibonacci-number/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-e1ph/)

#### 方法1:暴力递归

- 经典的种子题

```java
    public int fib(int n) {
        if(n==0) return 0;
        if(n==1) return 1;
        return fib(n-1)+fib(n-2);
    }
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[] memo;
public int fib(int n) {
    memo = new Integer[n+1];
    return recursive(n);
}   
private int recursive(int num){
    if(memo[num]!=null) return memo[num];
    if(num==0) return 0;
    if(num==1) return 1;
    return memo[num] = ( fib(num-1)+fib(num-2));
}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
public int fib(int n) {
    if(n<2) return n;
    int[] f= new int[n+1];
    f[0] = 0;
    f[1]= 1;
    for(int i = 2;i<=n;i++) f[i] =f[i-1]+f[i-2];
    return f[n];
}
```
### 爬楼梯

题目链接：[70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)

题解链接：[畅游面试中的动态规划套路-斐波那契数列系列之爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-jf88/)

#### 方法1:暴力递归

```java
public int climbStairs(int n) {
    if(n==1) return 1;
    if(n==2) return 2;
    return climbStairs(n-1)+climbStairs(n-2);
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
int[] memo ;
public int climbStairs(int n) {
    memo = new int[n+1];
    return helper(n);
}
private int helper(int n ){
    if(memo[n]!=0) return memo[n];
    if(n==1) return 1;
    if(n==2) return 2;
    return memo[n] =(helper(n-1)+helper(n-2));
}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
public int climbStairs(int n) {
    if(n<=2) return n;
    int[] dp = new int[n+1];
    dp[1] = 1;
    dp[2] =2;
    for(int i = 3;i<=n;++i) dp[i] = dp[i-2]+dp[i-1];
    return dp[n];
}
```

### 分解因子问题

Number factors

>  定义

**因子**：假如整数n除以m，结果是无余数的整数，那么我们称*m*就是*n*的因子。

**质因子**：在数论里，某一[正整数](https://baike.so.com/doc/6735250-6949628.html)的质因子指能整除该数的**[质数](https://blog.csdn.net/weixin_43272781/article/details/85058735)**整数。

**完数**：一个数的因子之和等于它本身，则该数为完数。

#### 方法1:暴力递归

```java
public int countWays(int n) {
    if (n == 0) return 1;  
    if (n == 1) return 1;
    if (n == 2) return 1;
    if (n == 3) return 2;
    int s1 = countWays(n - 1);
    int s3 = countWays(n - 3);
    int s4 = countWays(n - 4);
    return s1 + s3 + s4;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[] memo;

public int countWays(int n) {
    memo = new Integer[n + 1];
    return helper(n);
}

private int helper(int n) {
    if (memo[n] != null) return memo[n];
    if (n == 0) return 1;
    if (n == 1) return 1;
    if (n == 2) return 1;
    if (n == 3) return 2;
    int s1 = countWays(n - 1);
    int s3 = countWays(n - 3);
    int s4 = countWays(n - 4);
    return memo[n] = s1 + s3 + s4;
}
```

#### 方法3:自底向上填表DP(Bottom-up

```java
public int countWays(int n) {
    int[] f = new int[n + 1];
    f[0] = f[1] = f[2] = 1;
    f[3] = 2;
    for (int i = 4; i <= n; i++) {
        f[i] = f[i - 1] + f[i - 3] + f[i - 4];
    }
    return f[n];
}
```







### 最小跳跃次数

Minimum jumps to reach the end

```java
[2,3,1,1,2,4,2,0,1,1]
```



#### 方法1:暴力递归

```java
int INF = Integer.MAX_VALUE / 2;

public int countMinJumps(int[] jumps) {
    return helper(jumps, 0);
}

public int helper(int[] jumps, int currIdx) {
    if (currIdx == jumps.length - 1) return 0;
    if (jumps[currIdx] == 0) return INF;
    int total = INF;
    int start = currIdx + 1, end = currIdx + jumps[currIdx];
    while (start < jumps.length && start <= end) {
        int min = helper(jumps, start++);
        if (min != INF) total = Math.min(total, min + 1);
    }
    return total;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
int INF = Integer.MAX_VALUE / 2;
Integer[] memo;

public int countMinJumps(int[] jumps) {
    memo = new Integer[jumps.length];
    return helper(jumps, 0);
}

public int helper(int[] jumps, int currIdx) {
    if (currIdx == jumps.length - 1) return 0;
    if (jumps[currIdx] == 0) return INF;
    if (memo[currIdx] != null) return memo[currIdx];
    int total = INF;
    int start = currIdx + 1, end = currIdx + jumps[currIdx];
    while (start < jumps.length && start <= end) {
        int min = helper(jumps, start++);
        if (min != INF) total = Math.min(total, min + 1);
    }
    return memo[currIdx] = total;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
int INF = Integer.MAX_VALUE / 2;

public int countMinJumps(int[] jumps) {
    int n = jumps.length;
    int[] f = new int[n];
    Arrays.fill(f, INF);
    f[0] = 0;
    for (int start = 0; start < n - 1; start++) {
        for (int end = start + 1; end < jumps[start] + start && end < n; end++) {
            f[end] = Math.min(f[end], f[start] + 1);
        }
    }
    return f[n - 1];
}
```



### 跳跃游戏I

#### 方法1:暴力递归

```java
int N;

public boolean canJump(int[] nums) {
    N = nums.length;
    return helper(nums, 0);
}

public boolean helper(int[] nums, int idx) {
    if (idx >= N - 1) return true;
    for (int i = 1; i <= nums[idx]; i++) {
        if (helper(nums, idx + i)) {
            return true;
        }
    }
    return false;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
        Boolean[] memo;
        int N;

        public boolean canJump(int[] nums) {
            N = nums.length;
            memo = new Boolean[N];
            return helper(nums, 0);
        }

        public boolean helper(int[] nums, int idx) {
            if (idx >= N - 1) return true;
            if (memo[idx] != null) return memo[idx];
          	//当前idx为开始位置，跳跃的可能性有1...nums[idx]这些可能性
            for (int i = 1; i <= nums[idx]; i++) {
                if (helper(nums, idx + i)) {
                    return memo[idx + i] = true;//这个结果可以跳跃，缓存起来，idx+i当前位置起跳 跳i个位置
                }
            }
          	//不能跳，返回false
            return memo[idx] = false;
        }
```



#### 方法3:自底向上填表DP(Bottom-up)





### [跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

#### 方法1:暴力递归

```java
int N;

public int jump(int[] nums) {
    N = nums.length;
    return helper(nums, 0);
}

public int helper(int[] nums, int curr) {
    //当curr跳到末尾或者跳过末尾的时候，递归结束
    if (curr >= N - 1) return 0;
    int ans = Integer.MAX_VALUE / 2;
    //对于当前的curr索引，最多可以跳nums[curr]步，最少我们从1开始起跳，0没有意义，出去了
    for (int i = 1; i <= nums[curr]; i++) {
        //当前的索引是curr，可以跳i步，到i+curr ，每做一次，就跳了一次
        ans = Math.min(ans, helper(nums, i + curr) + 1);
    }
    return ans;
}
```



#### 方法2:自顶向下记忆化递归(Top-down)

```java
       int N;
        Integer[] memo;//返回当前位置索引curr跳到最后位置的最小步数

        public int jump(int[] nums) {
            N = nums.length;
            memo = new Integer[N];
            return helper(nums, 0);
        }

        /**
         * 返回当前位置索引curr跳到最后位置的最小步数
         *
         * @param nums 数组
         * @param curr 当前所处的位置
         * @return
         */
        public int helper(int[] nums, int curr) {
            //当curr跳到末尾或者跳过末尾的时候，递归结束
            if (curr >= N - 1) return 0;
            if (memo[curr] != null) return memo[curr];
            int ans = Integer.MAX_VALUE / 2;
            //对于当前的curr索引，最多可以跳nums[curr]步，最少我们从1开始起跳，0没有意义，出去了
            for (int i = 1; i <= nums[curr]; i++) {
                //当前的索引是curr，可以跳i步，到i+curr ，每做一次，就跳了一次
                ans = Math.min(ans, helper(nums, i + curr) + 1);
            }
            return memo[curr] = ans;
        }
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
public int jump(int[] nums) {
    int N = nums.length, INF = Integer.MAX_VALUE / 2;
    int[] f = new int[N];
    f[0] = 0;
    for (int i = 1; i < N; i++) {
        f[i] = INF;
        for (int j = 0; j < i; j++) {
            if (j + nums[j] >= i) f[i] = Math.min(f[i], f[j] + 1);
        }
    }
    return f[N - 1];
}
```

#### 方法4：贪心

- 从最后的下标出发，每次都找最靠左可以跳道`pos`的点,但是超时了，思路很好

```java
public int jump(int[] nums) {
    int pos = nums.length - 1;
    int step = 0;
    while (pos >= 0) {
        for (int i = 0; i < pos; i++) {
            if (i + nums[i] >= pos) {
                pos = i;
                step++;
                break;
            }
        }
    }
    return step;
}
```

- 自顶向下的方式

```java
        public int jump(int[] nums) {
            //当前位置所能到达的最右的下标（最右下标和当前前位置之间的这个一段区域的任何点都是可达的，这很关键），当前所处的位置，步数
            int rightMost = 0, currEnd = 0, step = 0;
            for (int i = 0; i < nums.length - 1; i++) {//这里跳到最后一个位置的前一个结束，不然结果会多一个
                rightMost = Math.max(rightMost, i + nums[i]);
                if (i == currEnd) {
                    step++;
                    currEnd = rightMost;
                }
            }
            return step;
        }
```





#### follow up





### 打家劫舍

题目链接：[198. House Robber](https://leetcode-cn.com/problems/house-robber/)

题解链接：[畅游面试中的动态规划套路-斐波那契数列系列之打家劫舍](https://leetcode-cn.com/problems/house-robber/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-rdkz/)

#### 方法1:暴力递归

```java
public int rob(int[] nums) {
    return helper(nums, nums.length - 1);
}

public int helper(int[] nums, int i) {
    if (i < 0) return 0;
    int steal = nums[i] + helper(nums, i - 2);
    int non_steal = helper(nums, i - 1);
    return Math.max(steal, non_steal);
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

> 从前往后跳

```java
Integer[] memo;

public int rob(int[] nums) {
    memo = new Integer[nums.length];
    return helper(nums, 0);
}

/**
 * @param nums
 * @param i    表示当前的房间号
 * @return
 */
public int helper(int[] nums, int i) {
    if (i >= nums.length) return 0;
    if (memo[i] != null) return memo[i];
    int steal = nums[i] + helper(nums, i + 2);
    int non_steal = helper(nums, i + 1);
    return memo[i] = Math.max(steal, non_steal);
}
```

> 从后往前跳

```java
Integer[] memo;

public int rob(int[] nums) {
    memo = new Integer[nums.length];
    return helper(nums, nums.length - 1);
}

public int helper(int[] nums, int i) {
    if (i < 0) return 0;
    if (memo[i] != null) return memo[i];
    int steal = nums[i] + helper(nums, i - 2);
    int non_steal = helper(nums, i - 1);
    return memo[i] = Math.max(steal, non_steal);
}
```

#### 方法3:自底向上填表DP(Bottom-up)

- `f[i][0]`表示对于当前的房间号`i-1` 不进行rob   `f[i][1]`表示进行rob
- 如果不rob的时候，其值是前一个房间号的 rob 和 不rob的最大值
- 如果rob的时候，其值是拿到当前房间的价值 + 前一个房间没有rob的的 价值`f[i - 1][0]`

```java
public int rob(int[] nums) {
    int n = nums.length;
    int[][] f = new int[n + 1][2];
    for (int i = 1; i <= n; i++) {
        f[i][0] = Math.max(f[i - 1][0], f[i - 1][1]);
        f[i][1] = nums[i - 1] + f[i - 1][0];
    }
    return Math.max(f[n][0], f[n][1]);
}
```

> Space O(1)

```java
public int rob(int[] nums) {
    int prev1 = 0, prev2 = 0; //表示rob与否的价值
    for (int v : nums) {
        int t = prev1;
        prev1 = Math.max(prev1, prev2);
        prev2 = t + v;
    }
    return Math.max(prev1, prev2);
}
```



### [403. 青蛙过河](https://leetcode-cn.com/problems/frog-jump/)

#### 方法1：暴力递归

- 略

#### 方法2：自顶向下记忆化递归(Top-down)

```java
        //k ： 当前的点 ， v ： 当前点可以跳跃的步数
        HashMap<Integer, Set<Integer>> vis = new HashMap<>();//prev这个点 以及这个点跳跃的步数 组成的状态
        HashSet<Integer> pos = new HashSet<>();//当前点的集合
        int end;

        public boolean canCross(int[] stones) {
            this.end = stones[stones.length - 1];
            for (int x : stones) {
                pos.add(x);
                vis.put(x, new HashSet<>());
            }
            return dfs(0, 1);//前一个位置从0开始，跳跃1步
        }

        /**
         * @param prev 前一个所在的位置
         * @param step 在前一个所在的位置上，下一步的步数
         * @return
         */
        public boolean dfs(int prev, int step) {
            int cur = prev + step;//当前要跳的点
            if (step < 0 || !pos.contains(cur)) return false; //步数或者当前点不在集合
            if (vis.get(prev).contains(step)) return false;//这种组合状态被搜索过
            vis.get(prev).add(step);
            if (cur == end) return true;//跳跃到终点位置
            //三种选择 cur作为下一轮的prev
            return dfs(cur, step - 1) || dfs(cur, step) || dfs(cur, step + 1);
        }
```

- todo//状态压缩技巧的解法

#### 方法3:自底向上填表DP(Bottom-up)

```java
public boolean canCross(int[] stones) {
    int n = stones.length;
    //f[i][j] 从第i个石头能否执行跳跃到j步的操作 能执行:true 不能执行:false
    boolean[][] f = new boolean[n][n + 1];//因为有k+1跳法 步数需要+1
    f[0][1] = true;
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            int diff = stones[i] - stones[j];
            if (diff < 0 || diff > n || !f[j][diff]) continue;
            f[i][diff] = true;
            if (diff - 1 >= 0) f[i][diff - 1] = true;
            if (diff + 1 <= n) f[i][diff + 1] = true;
            if (i == n - 1) return true;//提前返回
        }
    }
    return false;
}
```







[1654. Minimum Jumps to Reach Home](https://leetcode-cn.com/problems/minimum-jumps-to-reach-home/)

Minimum jumps with fee，蛙跳带有代价的问题



## 4.回文子序列

### 最长回文子序列

![dolphin-2329165_960_720](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\dolphin-2329165_960_720.jpg)

题目链接 ：[516. Longest Palindromic Subsequence](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

题解链接：[畅游面试中的动态规划套路-回文子序列系列之最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/a-fei-xue-suan-fa-zhi-si-ke-yi-dao-ti-516-zui-chan/)

#### 方法1:暴力递归

- `helper(String s, int start, int end) ` 函数表示，从`start`索引到`end`索引，所能找到的当前`s`的最长回文子序列的长度
- `base case`:
  - `start == end` 当前单词只有一个字符，长度为1
  - `start > end` 不合法

```java
public int longestPalindromeSubseq(String s) {
    return helper(s, 0, s.length() - 1);
}


private int helper(String s, int start, int end) {
    if (start == end) return 1;
    if (start > end) return 0;
    int ans = 0;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1) + 2;
    } else {
        ans = Math.max(helper(s, start + 1, end),
                       helper(s, start, end - 1));
    }
    return ans;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

> 对方法1进行记忆化修改后可以得到方法2

- 准备一个$helper(String s, int i, int j)$函数，其中`s`是字符串本身,`i`与`j`是起始位置，`memo`记录的是字符的最长子序列长度,$memo[0][n-1]$为所求
- 记忆化：当`memo[i][j]`不为`null`的时候，说明不是初始化的值，被求解过，直接返回
- 出口条件：
  - 当`i>j`时，返回`0`，因为没有意义，我们要求的起始位置`i`要小于`j`的
  - 当`i==j`时，返回`1`，只有一个字符，可以形成回文，即是其本身，长度为`1`
- 递归逻辑：
  - 当`s[i]==s[j]`时，说明需要在$helper(i+1,j-1)$基础上`+2`
  - 当`s[i]!=s[j]`时，要取$max[helper(i+1,j),helper(i,j-1)]$

```java
Integer[][] memo;

public int longestPalindromeSubseq(String s) {
    memo = new Integer[s.length()][s.length()];
    return helper(s, 0, s.length() - 1);
}


private int helper(String s, int start, int end) {
    if(memo[start][end]!=null) return memo[start][end];
    if (start == end) return 1;
    if (start > end) return 0;
    int ans = 0;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1) + 2;
    } else {
        ans = Math.max(helper(s, start + 1, end),
                       helper(s, start, end - 1));
    }
    return  memo[start][end] = ans ;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

- 定义`dp[i][j]`:表示`s[i...j]`之间的最长子序列的长度，**注意是子序列，不是子串，子序列是可以跳跃的，子串不可以**
  - 当`s[i]==s[j]`时，说明`i`与`j`位置的字符可以形成一个回文，这个回文的长度为`2`,根据`dp`的思想，其结果应该是依赖前面的结果,也就是`s[i+1 .... j-1]`这个范围的字符回文个数，也就是`dp[i+1][j-1]`，即$dp[i][j]=dp[i+1][j-1]+2$
  - 当`s[i]!=s[j]`时，说明`i`与`j`位置的字符不能形成一个回文，这个时候要看$s[i+1...j]$与$s[i...j-1]$这两段，因为$s[i+1]$可能与$s[i+2...j]$范围内的某个字符相同，拼凑出回文，因为$s[i]!=s[j]$,同理可得$s[i...j-1]$这段，故此，$dp[i][j]=max[dp[i][j-1],dp[i+1][j]]$
- `base case`:
  - 很容想到的是`i==j`时，说明`s[i...j]`只有一个字符，此时其自身可以形成一个回文，长度为`1`
  - 当`i>j`时，此时是不存在的，因为我们规定了`s[i...j]`起始位置`i`要小于结束位置`j`的，此时初始化为`0`
- 有两种遍历方式
  - 斜着遍历
  - 倒着遍历
- 返回结果$dp[0][n-1]$其实就是$s[0...n-1]$的最长回文子序列的长度

```java
 public int longestPalindromeSubseq1st(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
```

### 最长回文子串

题目链接 ：[5. Longest Palindromic Substring](https://leetcode-cn.com/problems/longest-palindromic-substring/)

题解链接：[畅游面试中的动态规划套路-回文子序列系列之最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-kvv1/)

#### 方法1:暴力递归

- `helper(String s, int start, int end)`
  - 表示`s`从`start`到`end`位置，是否有回文子串

- `base case`:
  - `start == end` : 相等时，说明只有一个字符了，返回`T`
  - `start +1== end`  ：两个字符的时候，比较两个字符是否相等

```java


        public String longestPalindrome(String s) {
            String ans = "";
            for (int i = 0; i < s.length(); i++) {
                for (int j = i; j < s.length(); j++) {
                    if (helper(s, i, j) && j - i + 1 > ans.length()) {
                        ans = s.substring(i, j + 1);
                    }
                }
            }
            return ans;
        }


        private boolean helper(String s, int start, int end) {
            if (start == end) return true;
            if (start + 1 == end) return s.charAt(start) == s.charAt(end);
            boolean ans = false;
            if (s.charAt(start) == s.charAt(end)) {
                ans = helper(s, start + 1, end - 1);
            }
            return ans;
        }
```

#### 方法2:自顶向下记忆化递归(Top-down)

> 脱胎与方法1，添加记忆化

```java
  Boolean[][] memo;

public String longestPalindrome(String s) {
    memo = new Boolean[s.length()][s.length()];
    String ans = "";
    for (int i = 0; i < s.length(); i++) {
        for (int j = i; j < s.length(); j++) {
            if (helper(s, i, j) && j - i + 1 > ans.length()) {
                ans = s.substring(i, j + 1);
            }
        }
    }
    return ans;
}


private boolean helper(String s, int start, int end) {
    if (start == end) return true;
    if (start + 1 == end) return s.charAt(start) == s.charAt(end);
    if (memo[start][end] != null) return memo[start][end];
    boolean ans = false;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1);
    }
    return memo[start][end] = ans;
}
```

#### 方法3:自底向上填表递归(Bottom-up)

- 其中`f[i][j]`表示`s`中，从`i`到`j`是否有回文子串
- `k`为遍历的字符长度，可以为`n`
  - 此时`i=0`,`j=i+k-1=0+n-1=n-1`

- 条件为当前字符`[i]==[j]`的时候，要么只有两个字符，要么砍头去尾，有回文子串

```java
        public String longestPalindrome(String s) {
            if (s == null || s.length() == 0) return "";
            int n = s.length();
            boolean[][] f = new boolean[n][n];
            for (int i = 0; i < n; ++i) f[i][i] = true;
            int maxLen = 1, start = 0;
            for (int k = 2; k <= n; k++) {
                // System.out.printf("k:%d\n", k);
                for (int i = 0; i < n - k + 1; i++) {
                    int j = i + k - 1;
                    // System.out.printf("i:%d,j:%d\n", i, j);
                    if (s.charAt(i) == s.charAt(j) && (k == 2 || f[i + 1][j - 1])) {
                        f[i][j] = true;
                        if (maxLen < k) {
                            maxLen = k;
                            start = i;
                        }
                    }
                }
            }
            return s.substring(start, start + maxLen);
        }
```

另外一种写法

- `k`为遍历的字符长度，可以为`n` 即当`i=0`的时候

```java
        public String longestPalindrome(String s) {
            if (s == null || s.length() <= 0) return s;
            int n = s.length();
            boolean[][] f = new boolean[n][n];
            for (int i = 0; i < n; i++) f[i][i] = true;
            int maxLen = 1, start = 0;
            for (int i = n - 1; i >= 0; i--) {
                for (int k = 1; k < n - i; k++) {
                    int j = k + i;
                    if (s.charAt(i) == s.charAt(j)) {
                        f[i][j] = (k == 1) || f[i + 1][j - 1];
                    }
                    if (f[i][j] && j - i + 1 > maxLen) {
                        maxLen = j - i + 1;
                        start = i;
                    }
                }
            }
            return s.substring(start, start + maxLen);
        }
```

#### 方法4:中心扩展法

```java
public String longestPalindrome(String s) {
    if (s == null || s.length() == 0) {
        return "";
    }
    int n = s.length();
    int start = 0, end = 0;
    for (int i = 0; i < n; i++) {
        //获取到当前点i 的奇回文和偶回文的最大长度
        int len1 = expandBySeed(s, i, i);
        int len2 = expandBySeed(s, i, i + 1);
        //取最大长度，然后扩展
        int len = Math.max(len1, len2);
        if (len > (end - start)) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}


/**
         * 由中心往两边扩散，返回满足最大回文的长度
         *
         * @param s
         * @param start
         * @param end
         * @return
         */
private int expandBySeed(String s, int start, int end) {
    int n = s.length();
    while (start >= 0 && end < n && s.charAt(start) == s.charAt(end)) {
        start--;
        end++;
    }
    return end - start - 1;
}
```

#### 方法5:Manacher算法

> 本动态规划的文章着重讲动态规划，涉及马拉车算法的内容不详细展开，下面的代码取自weiwei大佬的[题解](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)

```java
public class Solution {

    public String longestPalindrome(String s) {
        // 特判
        int len = s.length();
        if (len < 2) {
            return s;
        }

        // 得到预处理字符串
        String str = addBoundaries(s, '#');
        // 新字符串的长度
        int sLen = 2 * len + 1;

        // 数组 p 记录了扫描过的回文子串的信息
        int[] p = new int[sLen];

        // 双指针，它们是一一对应的，须同时更新
        int maxRight = 0;
        int center = 0;

        // 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度
        int maxLen = 1;
        // 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新        
        int start = 0;

        for (int i = 0; i < sLen; i++) {
            if (i < maxRight) {
                int mirror = 2 * center - i;
                // 这一行代码是 Manacher 算法的关键所在，要结合图形来理解
                p[i] = Math.min(maxRight - i, p[mirror]);
            }

            // 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中
            int left = i - (1 + p[i]);
            int right = i + (1 + p[i]);

            // left >= 0 && right < sLen 保证不越界
            // str.charAt(left) == str.charAt(right) 表示可以扩散 1 次
            while (left >= 0 && right < sLen && str.charAt(left) == str.charAt(right)) {
                p[i]++;
                left--;
                right++;

            }
            // 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者
            // 如果 maxRight 的值越大，进入上面 i < maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了
            if (i + p[i] > maxRight) {
                // maxRight 和 center 需要同时更新
                maxRight = i + p[i];
                center = i;
            }
            if (p[i] > maxLen) {
                // 记录最长回文子串的长度和相应它在原始字符串中的起点
                maxLen = p[i];
                start = (i - maxLen) / 2;
            }
        }
        return s.substring(start, start + maxLen);
    }


    /**
     * 创建预处理字符串
     *
     * @param s      原始字符串
     * @param divide 分隔字符
     * @return 使用分隔字符处理以后得到的字符串
     */
    private String addBoundaries(String s, char divide) {
        int len = s.length();
        if (len == 0) {
            return "";
        }
        if (s.indexOf(divide) != -1) {
            throw new IllegalArgumentException("参数错误，您传递的分割字符，在输入字符串中存在！");
        }
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < len; i++) {
            stringBuilder.append(divide);
            stringBuilder.append(s.charAt(i));
        }
        stringBuilder.append(divide);
        return stringBuilder.toString();
    }
}

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





### 回文子串的个数

题目链接 ：[647. Palindromic Substrings](https://leetcode-cn.com/problems/palindromic-substrings/)

题解链接：[畅游面试中的动态规划套路-回文子序列系列之回文子串的个数](https://leetcode-cn.com/problems/palindromic-substrings/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-5gyx/)

#### 方法1:暴力递归

```java
public int countSubstrings(String s) {
    int ans = 0, n = s.length();
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            ans += helper(s, i, j);
        }
    }
    return ans;
}

private int helper(String s, int start, int end) {
    if (start >= end) return 1;
    return s.charAt(start) == s.charAt(end) ? helper(s, start + 1, end - 1) : 0;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[][] memo;

public int countSubstrings(String s) {
    int ans = 0, n = s.length();
    memo = new Integer[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            ans += helper(s, i, j);
        }
    }
    return ans;
}

private int helper(String s, int start, int end) {
    if (start >= end) return 1;
    if (memo[start][end] != null) return memo[start][end];
    return memo[start][end] = s.charAt(start) == s.charAt(end) ? helper(s, start + 1, end - 1) : 0;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

- `f[i][j]`表示`i`到`j`上的回文子串的个数，分三种情况讨论
  - 长度为1：自己和自己组成回文，回文子串个数为1
  - 长度为2：是否相等，相等则有一个回文子串，不相等则没有
  - 长度为3：一般情况，看是否相等，不相等，则为0，相等，则砍头去尾，看`f[i + 1][j - 1] `

```java
public int countSubstrings(String s) {
    int n = s.length();
    int[][] f = new int[n][n];
    char[] chas = s.toCharArray();
    int ans = 0;
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i; j < n; j++) {
            if (i == j) f[i][j] = 1;
            else if (i + 1 == j) f[i][j] = chas[i] == chas[j] ? 1 : 0;
            else f[i][j] = chas[i] == chas[j] ? f[i + 1][j - 1] : 0;
            ans += f[i][j];
        }
    }
    return ans;
}
```

#### 方法4:中心扩展法

```java
/**
 * @param s
 * @return
 */
public int countSubstrings2nd(String s) {
    int result = 0;
    for (int i = 0; i < s.length(); i++) {
        //以当前点i位置，向两边扩展,以i i+1位置向两边扩展
        result += countSegment(s, i, i);
        result += countSegment(s, i, i + 1);
    }
    return result;
}


public int countSegment(String s, int start, int end) {
    int count = 0;
    //start往左边跑，end往右边跑，注意边界
    while (start >= 0 && end < s.length() && s.charAt(start--) == s.charAt(end++)) {
        count++;
    }
    return count;
}

```









### 让字符串成为回文串的最少插入次数

题目链接：[1312. Minimum Insertion Steps to Make a String Palindrome](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

老题解链接：[动态规划解最长子序列子串等一类问题之让字符串成为回文及其Follow Up[Sika Deer]](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution/dong-tai-gui-hua-jie-zui-chang-zi-xu-lie-zi-chuan-/)

新题解链接：[畅游面试中的动态规划套路-回文子序列系列之让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-yxoa/)

#### 方法1:暴力递归

- `helper(String s, int start, int end) `表示`s`从`start`到`end`想要形成回文，最少的插入次数
- `base case`:
  - 当`start >= end`时，一个字符的时候，本身就是回文，不需要添加，大于的时候，越界，无意义
- `[start]=[end]`的时候，砍头去尾向前看
- `[start]!=[end]`的时候，前后各添加一个，进入递归找最小的

```java
public int minInsertions(String s) {
    return helper(s, 0, s.length() - 1);
}

private int helper(String s, int start, int end) {
    if (start >= end) return 0;
    int ans;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1);
    } else {
        ans = Math.min(helper(s, start, end - 1), helper(s, start + 1, end)) + 1;
    }
    return ans;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[][] memo;
public int minInsertions(String s) {
    int n = s.length();
    memo = new Integer[n][n];
    return helper(s, 0, n - 1);
}

private int helper(String s, int start, int end) {
    if (memo[start][end] != null) return memo[start][end];
    if (start >= end) return 0;
    int ans;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1);
    } else {
        ans = Math.min(helper(s, start, end - 1), helper(s, start + 1, end)) + 1;
    }
    return memo[start][end] = ans;

}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
public int minInsertions(String s) {
    // $dp[i][j]$表示子串$str[i...j]$范围内的最少添加多少个字符后，可以形成回文子串
    char[] chas = s.toCharArray();
    int n = chas.length;
    int[][] dp = new int[n][n];
    for (int j = 1; j < n; j++) {
        dp[j - 1][j] = (chas[j - 1] == chas[j]) ? 0 : 1;
        for (int i = j - 2; i >= 0; i--) {
            if (chas[i] == chas[j]) dp[i][j] = dp[i + 1][j - 1];
            else dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
        }
    }
    return dp[0][s.length() - 1];
}
```

> 另外一种解法

使用[畅游面试中的动态规划套路-回文子序列系列之最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/a-fei-xue-suan-fa-zhi-si-ke-yi-dao-ti-516-zui-chan/)递减即可

```java
public int minDelBuildPalindrome(String s) {
    int n = s.length();
    int[][] f = new int[n][n];
    for (int i = n - 1; i >= 0; i--) {//i的顺序从高到低
        f[i][i] = 1;
        for (int j = i + 1; j < n; j++) {
            if (s.charAt(i) == s.charAt(j)) f[i][j] = f[i + 1][j - 1] + 2;
            else f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
        }
    }

    return n - f[0][n - 1];
}
```

### 怎么删掉最少字符构成回文

题目链接：Minimum Deletions in a String to make it a Palindrome

题解链接：[畅游面试中的动态规划套路-回文子序列系列之怎么删掉最少字符构成回文](https://leetcode-cn.com/circle/article/KyfGfp/)

> 这题和[畅游面试中的动态规划套路-回文子序列系列之最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/a-fei-xue-suan-fa-zhi-si-ke-yi-dao-ti-516-zui-chan/)一样，相当于求最长回文子序列，相减可得 s.length()-maxLPSLen



#### 方法1:暴力递归

```java
public int minDelBuildPalindrome(String s) {
    return s.length() - helper(s, 0, s.length() - 1);
}

private int helper(String s, int start, int end) {
    if (start == end) return 1;
    if (start > end) return 0;
    int ans;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1) + 2;
    } else {
        ans = Math.max(helper(s, start, end - 1), helper(s, start + 1, end));
    }
  //  System.out.println(ans);
    return ans;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[][] memo ;

public int minDelBuildPalindrome(String s) {
    memo = new Integer[s.length()][s.length()];
    return s.length() - helper(s, 0, s.length() - 1);
}

private int helper(String s, int start, int end) {
    if(memo[start][end]!=null) return memo[start][end];
    if (start == end) return 1;
    if (start > end) return 0;
    int ans;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1) + 2;
    } else {
        ans = Math.max(helper(s, start, end - 1), helper(s, start + 1, end));
    }
   // System.out.println(ans);
    return memo[start][end]=ans;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
public int minDelBuildPalindrome(String s) {
    int n = s.length();
    int[][] f = new int[n][n];
    for (int i = n - 1; i >= 0; i--) {//i的顺序从高到低
        f[i][i] = 1;
        for (int j = i + 1; j < n; j++) {
            if (s.charAt(i) == s.charAt(j)) f[i][j] = f[i + 1][j - 1] + 2;
            else f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
        }
    }

    return n - f[0][n - 1];
}
```



### 分割回文串

题目链接 ：[131. Palindrome Partitioning](https://leetcode-cn.com/problems/palindrome-partitioning/)

题解链接：[畅游面试中的动态规划套路-回文子序列系列之分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-yv16/)

#### 方法1:暴力递归

- `dfs(String s)` 返回当前字符`s`所能分割的回文串的组合
- 先判断左部分是不是回文，不是回文跳过，是回文，再递归去拿右部分的回文串组合
- 出口条件是当前的字符串为空的时候，也就是分割结束

```java
public List<List<String>> partition(String s) {
    return  dfs(s);
}

private List<List<String>> dfs(String s) {
    List<List<String>> res = new ArrayList<>();
    if (s == null || s.length() == 0) res.add(new ArrayList<>());
    for (int i = 0; i < s.length(); i++) {
        if (isPalindrome(s, 0, i)) {
            String left = s.substring(0, i + 1);
            for (List<String> rightList : dfs(s.substring(i + 1))) {
                List<String> sub = new ArrayList<>();
                sub.add(left);
                sub.addAll(rightList);
                res.add(sub);
            }
        }
    }
    return res;
}


private boolean isPalindrome(String s, int l, int r) {
    while (l < r) if (s.charAt(l++) != s.charAt(r--)) return false;
    return true;
}
```

- 另外一种写法

```java
List<List<String>> res = new ArrayList<>();

public List<List<String>> partition(String s) {
    dfs(s, 0, s.length(), new ArrayList<>());
    return res;
}


private void dfs(String s, int curr, int total, ArrayList<String> sub) {
    if (curr == total) {
        res.add(new ArrayList<>(sub));
        return;
    }
    for (int i = curr; i < total; i++) {
        if (isPalindrome(s, curr, i)) {
            sub.add(s.substring(curr, i + 1));
            dfs(s, i + 1, total, sub);
            sub.remove(sub.size() - 1);
        }
    }
}

private boolean isPalindrome(String s, int l, int r) {
    while (l < r) if (s.charAt(l++) != s.charAt(r--)) return false;
    return true;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

> 脱胎于方法1

```java
Map<String, List<List<String>>> memo = new HashMap<>();

public List<List<String>> partition(String s) {
    List<List<String>> dfs = dfs(s);
    return dfs;
}

private List<List<String>> dfs(String s) {
    if (memo.containsKey(s)) return memo.get(s);
    List<List<String>> res = new ArrayList<>();
    if (s == null || s.length() == 0) res.add(new ArrayList<>());
    for (int i = 0; i < s.length(); i++) {
        if (isPalindrome(s, 0, i)) {
            String left = s.substring(0, i + 1);
            //右部分从i+1开始
            for (List<String> rightList : dfs(s.substring(i + 1))) {
                List<String> sub = new ArrayList<>();
                sub.add(left);
                sub.addAll(rightList);
                res.add(sub);
            }
        }
    }
    memo.put(s, res);
    return res;
}


private boolean isPalindrome(String s, int l, int r) {
    while (l < r) if (s.charAt(l++) != s.charAt(r--)) return false;
    return true;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

- `dp[i][j]`表示`[i...j]`范围内子串能否形成回文，先初始化该`dp`表

```java
List<List<String>> res = new ArrayList<>();

public List<List<String>> partition(String s) {
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    for (int j = 0; j < n; j++) {
        for (int i = 0; i <= j; i++) {
            if (s.charAt(i) == s.charAt(j) && (j - i < 2 || dp[i + 1][j - 1])) dp[i][j] = true;
        }
    }
    dfs(s, 0, n, new ArrayList<>(), dp);
    return res;
}

private void dfs(String s, int i, int n, List<String> sub, boolean[][] dp) {
    if (i == n) {
        res.add(new ArrayList<>(sub));
        return;
    }
    for (int j = i; j < n; j++) {
        if (dp[i][j]) {
            sub.add(s.substring(i, j + 1));
            dfs(s, j + 1, n, sub, dp);
            sub.remove(sub.size() - 1);
        }
    }
}
```







## 5.最长子串

### 一些名词

- 最长上升子序列($LIS$):**`Longest Increasing Subsequence `**
- 最长连续序列($LCS$):**`Longest Consecutive Sequence `**
- 最长连续递增序列($LCIS$):**`Longest Continuous Increasing Subsequence`**
- 最长公共子序列($LCS$):**`Longest Common Subsequence`**





#### [1143. Longest Common Subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/)



#### [300. Longest Increasing Subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence/)



#### [1044. Longest Duplicate Substring](https://leetcode-cn.com/problems/longest-duplicate-substring/)





#### [1027. Longest Arithmetic Subsequence](https://leetcode-cn.com/problems/longest-arithmetic-subsequence/)







#### [1092. Shortest Common Supersequence ](https://leetcode-cn.com/problems/shortest-common-supersequence/)



Longest Common Substring，最长相同子串

https://www.lintcode.com/problem/79/





#### [1653. Minimum Deletions to Make String Balanced](https://leetcode-cn.com/problems/minimum-deletions-to-make-string-balanced/)

这个有一类题







#### [72. Edit Distance](https://leetcode-cn.com/problems/edit-distance/)







#### [97. Interleaving String](https://leetcode-cn.com/problems/interleaving-string/)





Maximum Sum Increasing Subsequence | DP-14



https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/



题目链接：[509. Fibonacci Number](https://leetcode-cn.com/problems/fibonacci-number/)

题解链接：[畅游面试中的动态规划套路-斐波那契数列系列之菲波那切数列](

#### 方法1:暴力递归



#### 方法2:自顶向下记忆化递归(Top-down)



#### 方法3:自底向上填表DP(Bottom-up)







## Reference

https://github.com/search?q=Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews

https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews/RM1BDv71V60

https://blog.csdn.net/IBelieve2016/article/details/104544763