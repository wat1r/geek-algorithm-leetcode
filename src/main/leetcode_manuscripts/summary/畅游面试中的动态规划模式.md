# 畅游面试中的动态规划套路

## 写在前面的话

> 本文主题是讲动态规划，思路和目录结构来源于收藏夹中的一个课程[Grokking Dynamic Programming Patterns for Coding Interviews](https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews),其中grok是深刻领会，深入掌握的意思，我翻译成**畅游**，加上自己的理解，消化(截取的课程的目录)，得到本文，文章很长，其实人生的路也很长，是吧？人生的路好走过吗...

## 0.什么是动态规划

> 动态规划(DP)是一种求解优化问题的算法，它将问题分解为更简单的子问题，并利用整体问题的最优解取决于子问题的最优解这一事实

看个例子**斐波那契数列**，众所周知，斐波那契数列是一系列的数字，其中每个数字都是前面两个数字的和，前几个斐波那契数列是0、1、1、2、3、5和8，以此类推。
如果我们要求计算第n个斐波那契数列，我们可以用下面的方程来做：

```java
Fib(n) = Fib(n-1) + Fib(n-2), for n > 1
```

我们可以清楚地看到，为了解决整个问题(即`Fib(n)`)，我们将其分解为两个更小的子问题(`Fib(n-1)`和`Fib(n-2)`)。这说明我们可以用DP来解决这个问题

### 动态规划的特点

在理解DP问题的不同方法之前，让我们先看看一个问题的哪些特征告诉我们可以应用DP来解决它。

### 1.重叠子问题

子问题是原始问题的更小粒度。如果找到它的解决方案涉及到多次解决相同的子问题，那么任何问题都有重叠的子问题。以斐波那契数列为例，为了找到`fib(4)`，我们需要将其分解为以下子问题:

![image-20210303191922492](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\image-20210303191922492.png)

我们可以清楚地看到重叠的子问题模式，因为`fib(2)`已经计算了两次，`fib(1)`已经计算了三次。

### 2.最优子结构性质

如果它的整体最优解可以由其子问题的最优解构造出来，那么任何问题都具有最优子结构性质。对于斐波那契数列，我们知道

```java
Fib(n) = Fib(n-1) + Fib(n-2)
```

这清楚地表明大小为`n`的问题已经被简化为大小为`n-1`和`n-2`的子问题。因此，斐波那契数具有最优子结构性质。

### 动态规划的方法

> DP问题一般有两种方式去解决

#### 2.1.自顶向下记忆化(Top-down)

在这种方法中，我们试图通过递归地找到较小子问题的解决方案来解决较大的问题。每当我们解决一个子问题时，对子问题的结果缓存起来，这样当它被多次调用时，我们就不会重复地解决它。相反，我们可以只返回保存的结果。这种存储已经解决的子问题的结果的技术叫做**记忆化**。

我们将在斐波那契数列的例子中看到这种技术。首先，让我们看看寻找第`n`个斐波那契数列的非`DP`递归解:

```java
class Fibonacci {

  public int CalculateFibonacci(int n) {
    if(n < 2) return n;
    return CalculateFibonacci(n-1) + CalculateFibonacci(n-2);
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```

> output

```java
5th Fibonacci is ---> 5
6th Fibonacci is ---> 8
7th Fibonacci is ---> 13
```

正如我们上面所看到的，这个问题显示了重叠子问题模式，所以让我们在这里利用记忆。我们可以使用一个数组来存储已经解决的子问题(请参阅高亮显示的行中的更改)。

```java
class Fibonacci {

  public int CalculateFibonacci(int n) {
    int memoize[] = new int[n+1];
    return CalculateFibonacciRecursive(memoize, n);
  }

  public int CalculateFibonacciRecursive(int[] memoize, int n) {
    if(n < 2)
      return n;
    // if we have already solved this subproblem, simply return the result from the cache
    if(memoize[n] != 0)
      return memoize[n];

    memoize[n] = CalculateFibonacciRecursive(memoize, n-1) + CalculateFibonacciRecursive(memoize, n-2);
    return memoize[n];
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```

#### 2.2.自底向上填表(Bottom-up)

**填表**与自顶向下方法相反，避免了递归。在这种方法中，我们**自底向上**地解决问题(即首先解决所有相关的子问题)。这通常通过填充一个`n`维表来完成。根据表中的结果，然后计算顶部/原始问题的解决方案。

**填表**与**记忆化**是相反的，因为在记忆化中，我们解决问题，并维护已经解决的子问题的映射。换句话说，在记忆化中，我们从上到下，也就是说我们先解决最上面的问题(通常递归下来解决子问题)。

让我们将**填表**应用到我们的斐波那契数列的例子中。因为我们知道每个斐波那契数都是前面两个数的和，所以我们可以使用这个事实来填充我们的表。

下面是自底向上动态规划的代码:

```java
class Fibonacci {

  public int CalculateFibonacci(int n) {
    if (n==0) return 0;
    int dp[] = new int[n+1];
    //base cases
    dp[0] = 0;
    dp[1] = 1;
    for(int i=2; i<=n; i++)
      dp[i] = dp[i-1] + dp[i-2];
    return dp[n];
  }

  public static void main(String[] args) {
    Fibonacci fib = new Fibonacci();
    System.out.println("5th Fibonacci is ---> " + fib.CalculateFibonacci(5));
    System.out.println("6th Fibonacci is ---> " + fib.CalculateFibonacci(6));
    System.out.println("7th Fibonacci is ---> " + fib.CalculateFibonacci(7));
  }
}
```

**我们将始终从一个暴力递归解决方案开始，这是开始解决任何DP问题的最佳方式。**一旦我们有了递归的解决方案，我们就会应用**记忆化**和**填表**。

让我们应用这些知识来解决一些常见的DP问题。

## 1.01背包



![jellyfish-1730018_640](C:\Users\wangzhou\Desktop\jellyfish-1730018_640.jpg)



### 01背包问题

考虑到`N`个物品的`weights`和`profits`，我们被要求把这些物品放在一个容量为`C`的背包里。目标是背包中的物品获得最大的`profits`。每个物品只能选择一次，因为物品的数量是有限制的。

让我们以`Merry's`为例，他想在背包里装一些水果以获得最大的`profits`。以下是水果的`weights`和`profits`：

```java
Items: { Apple, Orange, Banana, Melon }
Weights: { 2, 3, 1, 4 }
Profits: { 4, 5, 3, 7 }
Knapsack capacity: 5
```

让我们试着把不同的水果组合放在背包里，使它们的总重量不超过5：

```java
Apple + Orange (total weight 5) => 9 profit
Apple + Banana (total weight 3) => 7 profit
Orange + Banana (total weight 4) => 8 profit
Banana + Melon (total weight 5) => 10 profit
```

这说明**Banana + Melon**是最好的组合，因为有最大的`profits`，而且总重量不超过背包容量。

#### 问题描述

给定两个整数数组来表示`N`个的`weights`和`profits`，我们需要找到这些项的子集，从而使我们获得最大`profits`，使其累积`weights`不超过给定的`C`。每个物品只能选择一次，这意味着我们要么把一个物品放在背包里，要么跳过它。

#### 常规方式

一个基本的暴力解决方案可以是尝试给定物品的所有组合（正如我们上面所做的），允许我们选择`profits`最大且`weights`不超过`C`的物品。以四个物品（A、B、C和D）为例，如下图所示。要尝试所有组合，我们的算法将如下所示：

```java
for each item 'i' 
  create a new set which INCLUDES item 'i' if the total weight does not exceed the capacity, and 
     recursively process the remaining capacity and items
  create a new set WITHOUT item 'i', and recursively process the remaining items 
return the set from the above two sets with higher profit 
```

![image-20210316184455380](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\image-20210316184455380.png)

所有绿色框的总`weights`小于或等于容量（7），所有红色框的重量大于7。我们最好的解决方案是项目[B，D]的总`profits`为22，总`weights`为7。

```java
class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    return this.knapsackRecursive(profits, weights, capacity, 0);
  }

  private int knapsackRecursive(int[] profits, int[] weights, int capacity, int currentIndex) {
    // base checks
    if (capacity <= 0 || currentIndex >= profits.length)
      return 0;

    // recursive call after choosing the element at the currentIndex
    // if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this
    int profit1 = 0;
    if( weights[currentIndex] <= capacity )
        profit1 = profits[currentIndex] + knapsackRecursive(profits, weights,
                capacity - weights[currentIndex], currentIndex + 1);

    // recursive call after excluding the element at the currentIndex
    int profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + 1);

    return Math.max(profit1, profit2);
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

上述算法的时间复杂度是指数级的$O(2^n)$，其中n表示物品总数。这也可以从上面的递归树中得到证实。正如我们所看到的，我们将有总共31个递归调用-通过计算$O(2^n)+O(2^n)-1$，近似等价于$O(2^n)$

空间复杂度为$O(n)$。此空间将用于存储递归堆栈。因为我们的递归算法是以深度优先的方式处理的，这意味着，在任何时候，调用堆栈上的递归调用不能超过`n`个。

让我们直观地绘制递归调用，看看是否有重叠的子问题。如我们所见，在每个递归调用中，`profits`和`weights`数组保持不变，只有容量和`currentIndex`发生变化。为了简单起见，让我们用`c`表示容量，用`i`表示`currentIndex`：

![image-20210316185940528](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\image-20210316185940528.png)

可以清楚地看到`c:4，i=3`被调用了两次；因此有一个重叠的子问题模式。如上所述，重叠的子问题可以通过记忆化来解决。

#### 自顶向下记忆化动态规划

可以用记忆化来避免重叠的子问题。要重申，记忆化是当我们存储所有先前解决的子问题的结果，并返回内存中的结果。

由于递归函数`knapsackRecursive()`中有两个变量（`capacity`和`currentIndex`），所以可以使用二维数组来存储所有已解决子问题的结果。如上所述，需要为每个子数组（即，对于每个可能的索引`i`）和每个可能的容量`c`存储结果。

```java
class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    Integer[][] dp = new Integer[profits.length][capacity + 1];
    return this.knapsackRecursive(dp, profits, weights, capacity, 0);
  }

  private int knapsackRecursive(Integer[][] dp, int[] profits, int[] weights, int capacity,
      int currentIndex) {

    // base checks
    if (capacity <= 0 || currentIndex >= profits.length)
      return 0;

    // if we have already solved a similar problem, return the result from memory
    if(dp[currentIndex][capacity] != null)
      return dp[currentIndex][capacity];

    // recursive call after choosing the element at the currentIndex
    // if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this
    int profit1 = 0;
    if( weights[currentIndex] <= capacity )
        profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights,
                capacity - weights[currentIndex], currentIndex + 1);

    // recursive call after excluding the element at the currentIndex
    int profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + 1);

    dp[currentIndex][capacity] = Math.max(profit1, profit2);
    return dp[currentIndex][capacity];
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

**时间复杂度和空间复杂度如何** : 因为记忆化的数组`dp[profits.length][capacity+1]`存储所有子问题的结果，可以得出这样的结论：我们不会有超过`N*C`的子问题（其中`N`是物品数量，`C`是背包容量）。这意味着时间复杂度将是$O(N*C)$。

因为用到了数组，空间复杂度是$O(N*C)$，除此之外，用到了$O(N)$的空间做递归栈使用，总的空间是$O(N*C+C)$ 近似于$O(N*C)$

#### 自底向上动态规划

以自底向上的方式，尝试从上面的解决方案填充`dp[][]`数组。本质上，我们希望找到每个子数组和每个可能容量的最大`profits`。这意味着，`dp[i][c]`将代表从第一个`i`物品，容量为`c`的最大背包`profits`。

因此，对于索引`‘i’ (0 <= i < items.length) `处的每个物品和容量`c（0<=c<=capacity）`，有两个选项：

1.不选`i`物品，获取的是子数组排除掉`i`物品的`profits`  `dp[i-1][c]`

2.选`i`物品，获取的是当前`i`物品的价值，和扣除掉`i`物品后的`profits`  `profits[i]+dp[i-1][c-weights[i]]`

最后，最优解将是上述两个值的最大值:

```java
 dp[i][c] = max (dp[i-1][c], profits[i] + dp[i-1][c-weights[i]]) 
```



```java
class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    // basic checks
    if (capacity <= 0 || profits.length == 0 || weights.length != profits.length)
      return 0;

    int n = profits.length;
    int[][] dp = new int[n][capacity + 1];

    // populate the capacity=0 columns, with '0' capacity we have '0' profit
    for(int i=0; i < n; i++)
      dp[i][0] = 0;

    // if we have only one weight, we will take it if it is not more than the capacity
    for(int c=0; c <= capacity; c++) {
      if(weights[0] <= c)
        dp[0][c] = profits[0];
    }

    // process all sub-arrays for all the capacities
    for(int i=1; i < n; i++) {
      for(int c=1; c <= capacity; c++) {
        int profit1= 0, profit2 = 0;
        // include the item, if it is not more than the capacity
        if(weights[i] <= c)
          profit1 = profits[i] + dp[i-1][c-weights[i]];
        // exclude the item
        profit2 = dp[i-1][c];
        // take maximum
        dp[i][c] = Math.max(profit1, profit2);
      }
    }

    // maximum profit will be at the bottom-right corner.
    return dp[n-1][capacity];
  }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    System.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

时间复杂度和空间复杂度都是$O(N*C)$(其中`N`是物品数量，`C`是背包容量)

#### 如何找到已选择的物品

我们知道最终`profits`在右下角，因此，我们将从那里开始寻找背包中的物品。

在每一步中，我们都有两个选项：选或不选。如果不选，那么我们从剩余的物品中获取利润（即，从它正上方的单元格）；如果选，那么我们跳转到剩余的利润以查找更多的物品。

让我们从上面的例子来理解这一点：

![image-20210316194512922](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\image-20210316194512922.png)



1.`22`不是来自顶部单元格（即17），因此我们必须在索引`3`中选此物品（即`D`）。

2.从`22`中减去`D`的利润，得到剩余的利润`6`。然后我们跳到同一行的利润`6`。

3.`6`来自最上面的单元格，所以我们跳到`2`行。

4.同样，`6`来自最上面的单元格，所以我们跳到`1`行。

5.`6`与顶部单元格不同，因此必须包含此物品（即`B`）。

6.从`6`中减去`B`的利润得到利润`0`。然后跳到同一行的利润`0`。一旦剩余利润为零，我们就可以完成商品搜索。

所以进入背包的物品是{B，D}。

> 打印出这些选择的物品

```java
import java.util.*;

class Knapsack {

  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    // base checks
    if (capacity <= 0 || profits.length == 0 || weights.length != profits.length)
      return 0;

    int n = profits.length;
    int[][] dp = new int[n][capacity + 1];

    // populate the capacity=0 columns, with '0' capacity we have '0' profit
    for(int i=0; i < n; i++)
      dp[i][0] = 0;

    // if we have only one weight, we will take it if it is not more than the capacity
    for(int c=0; c <= capacity; c++) {
      if(weights[0] <= c)
        dp[0][c] = profits[0];
    }

    // process all sub-arrays for all the capacities
    for(int i=1; i < n; i++) {
      for(int c=1; c <= capacity; c++) {
        int profit1= 0, profit2 = 0;
        // include the item, if it is not more than the capacity
        if(weights[i] <= c)
          profit1 = profits[i] + dp[i-1][c-weights[i]];
        // exclude the item
        profit2 = dp[i-1][c];
        // take maximum
        dp[i][c] = Math.max(profit1, profit2);
      }
    }

    printSelectedElements(dp, weights, profits, capacity);
    // maximum profit will be at the bottom-right corner.
    return dp[n-1][capacity];
  }

 private void printSelectedElements(int dp[][], int[] weights, int[] profits, int capacity){
   System.out.print("Selected weights:");
   int totalProfit = dp[weights.length-1][capacity];
   for(int i=weights.length-1; i > 0; i--) {
     if(totalProfit != dp[i-1][capacity]) {
       System.out.print(" " + weights[i]);
       capacity -= weights[i];
       totalProfit -= profits[i];
     }
   }

   if(totalProfit != 0)
     System.out.print(" " + weights[0]);
   System.out.println("");
 }

  public static void main(String[] args) {
    Knapsack ks = new Knapsack();
    int[] profits = {1, 6, 10, 16};
    int[] weights = {1, 2, 3, 5};
    int maxProfit = ks.solveKnapsack(profits, weights, 7);
    System.out.println("Total knapsack profit ---> " + maxProfit);
    maxProfit = ks.solveKnapsack(profits, weights, 6);
    Syst
        em.out.println("Total knapsack profit ---> " + maxProfit);
  }
}
```

空间复杂度`O(1)`的做法









题目链接：[509. Fibonacci Number](https://leetcode-cn.com/problems/fibonacci-number/)

题解链接：[畅游面试中的动态规划套路-斐波那契数列系列之菲波那切数列](

#### 方法1:暴力递归



#### 方法2:自顶向下记忆化递归(Top-down)



#### 方法3:自底向上填表DP(Bottom-up)







「力扣」上的 0-1 背包问题：

「力扣」第 416 题：分割等和子集（中等）；
「力扣」第 474 题：一和零（中等）；
「力扣」第 494 题：目标和（中等）；
「力扣」第 879 题：盈利计划（困难）；
「力扣」上的 完全背包问题：

「力扣」第 322 题：零钱兑换（中等）；
「力扣」第 518 题：零钱兑换 II（中等）；
「力扣」第 1449 题：数位成本和为目标值的最大数字（困难）。







## 2.完全背包















![illustration-1705197_640](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\illustration-1705197_640.jpg)









































































































## 3.斐波那契数列

更多内容：

[畅游面试中的动态规划套路](https://blog.csdn.net/wat1r/article/details/114377702)



![watercolour-4799014_640](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\watercolour-4799014_640.jpg)



### 斐波那契数

题目链接：[509. Fibonacci Number](https://leetcode-cn.com/problems/fibonacci-number/)

题解链接：[畅游面试中的动态规划套路-斐波那契数列系列之斐波那契数列](https://leetcode-cn.com/problems/fibonacci-number/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-e1ph/)

#### 方法1:暴力递归

- 经典的种子题

```java
    public int fib(int n) {
        if(n==0) return 0;
        if(n==1) return 1;
        return fib(n-1)+fib(n-2);
    }
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[] memo;
public int fib(int n) {
    memo = new Integer[n+1];
    return recursive(n);
}   
private int recursive(int num){
    if(memo[num]!=null) return memo[num];
    if(num==0) return 0;
    if(num==1) return 1;
    return memo[num] = ( fib(num-1)+fib(num-2));
}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
public int fib(int n) {
    if(n<2) return n;
    int[] f= new int[n+1];
    f[0] = 0;
    f[1]= 1;
    for(int i = 2;i<=n;i++) f[i] =f[i-1]+f[i-2];
    return f[n];
}
```
### 爬楼梯

题目链接：[70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)

题解链接：[畅游面试中的动态规划套路-斐波那契数列系列之爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-jf88/)

#### 方法1:暴力递归

```java
public int climbStairs(int n) {
    if(n==1) return 1;
    if(n==2) return 2;
    return climbStairs(n-1)+climbStairs(n-2);
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
int[] memo ;
public int climbStairs(int n) {
    memo = new int[n+1];
    return helper(n);
}
private int helper(int n ){
    if(memo[n]!=0) return memo[n];
    if(n==1) return 1;
    if(n==2) return 2;
    return memo[n] =(helper(n-1)+helper(n-2));
}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
public int climbStairs(int n) {
    if(n<=2) return n;
    int[] dp = new int[n+1];
    dp[1] = 1;
    dp[2] =2;
    for(int i = 3;i<=n;++i) dp[i] = dp[i-2]+dp[i-1];
    return dp[n];
}
```

### 分解因子问题

Number factors

>  定义

**因子**：假如整数n除以m，结果是无余数的整数，那么我们称*m*就是*n*的因子。

**质因子**：在数论里，某一[正整数](https://baike.so.com/doc/6735250-6949628.html)的质因子指能整除该数的**[质数](https://blog.csdn.net/weixin_43272781/article/details/85058735)**整数。

**完数**：一个数的因子之和等于它本身，则该数为完数。

#### 方法1:暴力递归

```java
public int countWays(int n) {
    if (n == 0) return 1;  
    if (n == 1) return 1;
    if (n == 2) return 1;
    if (n == 3) return 2;
    int s1 = countWays(n - 1);
    int s3 = countWays(n - 3);
    int s4 = countWays(n - 4);
    return s1 + s3 + s4;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[] memo;

public int countWays(int n) {
    memo = new Integer[n + 1];
    return helper(n);
}

private int helper(int n) {
    if (memo[n] != null) return memo[n];
    if (n == 0) return 1;
    if (n == 1) return 1;
    if (n == 2) return 1;
    if (n == 3) return 2;
    int s1 = countWays(n - 1);
    int s3 = countWays(n - 3);
    int s4 = countWays(n - 4);
    return memo[n] = s1 + s3 + s4;
}
```

#### 方法3:自底向上填表DP(Bottom-up

```java
public int countWays(int n) {
    int[] f = new int[n + 1];
    f[0] = f[1] = f[2] = 1;
    f[3] = 2;
    for (int i = 4; i <= n; i++) {
        f[i] = f[i - 1] + f[i - 3] + f[i - 4];
    }
    return f[n];
}
```







### 最小跳跃次数

Minimum jumps to reach the end

#### 方法1:暴力递归

```java
int INF = Integer.MAX_VALUE / 2;

public int countMinJumps(int[] jumps) {
    return helper(jumps, 0);
}

public int helper(int[] jumps, int currIdx) {
    if (currIdx == jumps.length - 1) return 0;
    if (jumps[currIdx] == 0) return INF;
    int total = INF;
    int start = currIdx + 1, end = currIdx + jumps[currIdx];
    while (start < jumps.length && start <= end) {
        int min = helper(jumps, start++);
        if (min != INF) total = Math.min(total, min + 1);
    }
    return total;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
int INF = Integer.MAX_VALUE / 2;
Integer[] memo;

public int countMinJumps(int[] jumps) {
    memo = new Integer[jumps.length];
    return helper(jumps, 0);
}

public int helper(int[] jumps, int currIdx) {
    if (currIdx == jumps.length - 1) return 0;
    if (jumps[currIdx] == 0) return INF;
    if (memo[currIdx] != null) return memo[currIdx];
    int total = INF;
    int start = currIdx + 1, end = currIdx + jumps[currIdx];
    while (start < jumps.length && start <= end) {
        int min = helper(jumps, start++);
        if (min != INF) total = Math.min(total, min + 1);
    }
    return memo[currIdx] = total;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
int INF = Integer.MAX_VALUE / 2;

public int countMinJumps(int[] jumps) {
    int n = jumps.length;
    int[] f = new int[n];
    Arrays.fill(f, INF);
    f[0] = 0;
    for (int start = 0; start < n - 1; start++) {
        for (int end = start + 1; end < jumps[start] + start && end < n; end++) {
            f[end] = Math.min(f[end], f[start] + 1);
        }
    }
    return f[n - 1];
}
```

### 打家劫舍

题目链接：[198. House Robber](https://leetcode-cn.com/problems/house-robber/)

题解链接：[畅游面试中的动态规划套路-斐波那契数列系列之打家劫舍](https://leetcode-cn.com/problems/house-robber/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-rdkz/)

#### 方法1:暴力递归

```java
public int rob(int[] nums) {
    return helper(nums, nums.length - 1);
}

public int helper(int[] nums, int i) {
    if (i < 0) return 0;
    int steal = nums[i] + helper(nums, i - 2);
    int non_steal = helper(nums, i - 1);
    return Math.max(steal, non_steal);
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

> 从前往后跳

```java
Integer[] memo;

public int rob(int[] nums) {
    memo = new Integer[nums.length];
    return helper(nums, 0);
}

/**
 * @param nums
 * @param i    表示当前的房间号
 * @return
 */
public int helper(int[] nums, int i) {
    if (i >= nums.length) return 0;
    if (memo[i] != null) return memo[i];
    int steal = nums[i] + helper(nums, i + 2);
    int non_steal = helper(nums, i + 1);
    return memo[i] = Math.max(steal, non_steal);
}
```

> 从后往前跳

```java
Integer[] memo;

public int rob(int[] nums) {
    memo = new Integer[nums.length];
    return helper(nums, nums.length - 1);
}

public int helper(int[] nums, int i) {
    if (i < 0) return 0;
    if (memo[i] != null) return memo[i];
    int steal = nums[i] + helper(nums, i - 2);
    int non_steal = helper(nums, i - 1);
    return memo[i] = Math.max(steal, non_steal);
}
```

#### 方法3:自底向上填表DP(Bottom-up)

- `f[i][0]`表示对于当前的房间号`i-1` 不进行rob   `f[i][1]`表示进行rob
- 如果不rob的时候，其值是前一个房间号的 rob 和 不rob的最大值
- 如果rob的时候，其值是拿到当前房间的价值 + 前一个房间没有rob的的 价值`f[i - 1][0]`

```java
public int rob(int[] nums) {
    int n = nums.length;
    int[][] f = new int[n + 1][2];
    for (int i = 1; i <= n; i++) {
        f[i][0] = Math.max(f[i - 1][0], f[i - 1][1]);
        f[i][1] = nums[i - 1] + f[i - 1][0];
    }
    return Math.max(f[n][0], f[n][1]);
}
```

> Space O(1)

```java
public int rob(int[] nums) {
    int prev1 = 0, prev2 = 0; //表示rob与否的价值
    for (int v : nums) {
        int t = prev1;
        prev1 = Math.max(prev1, prev2);
        prev2 = t + v;
    }
    return Math.max(prev1, prev2);
}
```





[1654. Minimum Jumps to Reach Home](https://leetcode-cn.com/problems/minimum-jumps-to-reach-home/)

Minimum jumps with fee，蛙跳带有代价的问题



## 4.回文子序列

### 最长回文子序列

![dolphin-2329165_960_720](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\summary\畅游面试中的动态规划模式.assets\dolphin-2329165_960_720.jpg)

题目链接 ：[516. Longest Palindromic Subsequence](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

题解链接：[畅游面试中的动态规划套路-回文子序列系列之最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/a-fei-xue-suan-fa-zhi-si-ke-yi-dao-ti-516-zui-chan/)

#### 方法1:暴力递归

- `helper(String s, int start, int end) ` 函数表示，从`start`索引到`end`索引，所能找到的当前`s`的最长回文子序列的长度
- `base case`:
  - `start == end` 当前单词只有一个字符，长度为1
  - `start > end` 不合法

```java
public int longestPalindromeSubseq(String s) {
    return helper(s, 0, s.length() - 1);
}


private int helper(String s, int start, int end) {
    if (start == end) return 1;
    if (start > end) return 0;
    int ans = 0;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1) + 2;
    } else {
        ans = Math.max(helper(s, start + 1, end),
                       helper(s, start, end - 1));
    }
    return ans;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

> 对方法1进行记忆化修改后可以得到方法2

- 准备一个$helper(String s, int i, int j)$函数，其中`s`是字符串本身,`i`与`j`是起始位置，`memo`记录的是字符的最长子序列长度,$memo[0][n-1]$为所求
- 记忆化：当`memo[i][j]`不为`null`的时候，说明不是初始化的值，被求解过，直接返回
- 出口条件：
  - 当`i>j`时，返回`0`，因为没有意义，我们要求的起始位置`i`要小于`j`的
  - 当`i==j`时，返回`1`，只有一个字符，可以形成回文，即是其本身，长度为`1`
- 递归逻辑：
  - 当`s[i]==s[j]`时，说明需要在$helper(i+1,j-1)$基础上`+2`
  - 当`s[i]!=s[j]`时，要取$max[helper(i+1,j),helper(i,j-1)]$

```java
Integer[][] memo;

public int longestPalindromeSubseq(String s) {
    memo = new Integer[s.length()][s.length()];
    return helper(s, 0, s.length() - 1);
}


private int helper(String s, int start, int end) {
    if(memo[start][end]!=null) return memo[start][end];
    if (start == end) return 1;
    if (start > end) return 0;
    int ans = 0;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1) + 2;
    } else {
        ans = Math.max(helper(s, start + 1, end),
                       helper(s, start, end - 1));
    }
    return  memo[start][end] = ans ;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

- 定义`dp[i][j]`:表示`s[i...j]`之间的最长子序列的长度，**注意是子序列，不是子串，子序列是可以跳跃的，子串不可以**
  - 当`s[i]==s[j]`时，说明`i`与`j`位置的字符可以形成一个回文，这个回文的长度为`2`,根据`dp`的思想，其结果应该是依赖前面的结果,也就是`s[i+1 .... j-1]`这个范围的字符回文个数，也就是`dp[i+1][j-1]`，即$dp[i][j]=dp[i+1][j-1]+2$
  - 当`s[i]!=s[j]`时，说明`i`与`j`位置的字符不能形成一个回文，这个时候要看$s[i+1...j]$与$s[i...j-1]$这两段，因为$s[i+1]$可能与$s[i+2...j]$范围内的某个字符相同，拼凑出回文，因为$s[i]!=s[j]$,同理可得$s[i...j-1]$这段，故此，$dp[i][j]=max[dp[i][j-1],dp[i+1][j]]$
- `base case`:
  - 很容想到的是`i==j`时，说明`s[i...j]`只有一个字符，此时其自身可以形成一个回文，长度为`1`
  - 当`i>j`时，此时是不存在的，因为我们规定了`s[i...j]`起始位置`i`要小于结束位置`j`的，此时初始化为`0`
- 有两种遍历方式
  - 斜着遍历
  - 倒着遍历
- 返回结果$dp[0][n-1]$其实就是$s[0...n-1]$的最长回文子序列的长度

```java
 public int longestPalindromeSubseq1st(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
```

### 最长回文子串

题目链接 ：[5. Longest Palindromic Substring](https://leetcode-cn.com/problems/longest-palindromic-substring/)

题解链接：[畅游面试中的动态规划套路-回文子序列系列之最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-kvv1/)

#### 方法1:暴力递归

- `helper(String s, int start, int end)`
  - 表示`s`从`start`到`end`位置，是否有回文子串

- `base case`:
  - `start == end` : 相等时，说明只有一个字符了，返回`T`
  - `start +1== end`  ：两个字符的时候，比较两个字符是否相等

```java


        public String longestPalindrome(String s) {
            String ans = "";
            for (int i = 0; i < s.length(); i++) {
                for (int j = i; j < s.length(); j++) {
                    if (helper(s, i, j) && j - i + 1 > ans.length()) {
                        ans = s.substring(i, j + 1);
                    }
                }
            }
            return ans;
        }


        private boolean helper(String s, int start, int end) {
            if (start == end) return true;
            if (start + 1 == end) return s.charAt(start) == s.charAt(end);
            boolean ans = false;
            if (s.charAt(start) == s.charAt(end)) {
                ans = helper(s, start + 1, end - 1);
            }
            return ans;
        }
```

#### 方法2:自顶向下记忆化递归(Top-down)

> 脱胎与方法1，添加记忆化

```java
  Boolean[][] memo;

public String longestPalindrome(String s) {
    memo = new Boolean[s.length()][s.length()];
    String ans = "";
    for (int i = 0; i < s.length(); i++) {
        for (int j = i; j < s.length(); j++) {
            if (helper(s, i, j) && j - i + 1 > ans.length()) {
                ans = s.substring(i, j + 1);
            }
        }
    }
    return ans;
}


private boolean helper(String s, int start, int end) {
    if (start == end) return true;
    if (start + 1 == end) return s.charAt(start) == s.charAt(end);
    if (memo[start][end] != null) return memo[start][end];
    boolean ans = false;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1);
    }
    return memo[start][end] = ans;
}
```

#### 方法3:自底向上填表递归(Bottom-up)

- 其中`f[i][j]`表示`s`中，从`i`到`j`是否有回文子串
- `k`为遍历的字符长度，可以为`n`
  - 此时`i=0`,`j=i+k-1=0+n-1=n-1`

- 条件为当前字符`[i]==[j]`的时候，要么只有两个字符，要么砍头去尾，有回文子串

```java
        public String longestPalindrome(String s) {
            if (s == null || s.length() == 0) return "";
            int n = s.length();
            boolean[][] f = new boolean[n][n];
            for (int i = 0; i < n; ++i) f[i][i] = true;
            int maxLen = 1, start = 0;
            for (int k = 2; k <= n; k++) {
                // System.out.printf("k:%d\n", k);
                for (int i = 0; i < n - k + 1; i++) {
                    int j = i + k - 1;
                    // System.out.printf("i:%d,j:%d\n", i, j);
                    if (s.charAt(i) == s.charAt(j) && (k == 2 || f[i + 1][j - 1])) {
                        f[i][j] = true;
                        if (maxLen < k) {
                            maxLen = k;
                            start = i;
                        }
                    }
                }
            }
            return s.substring(start, start + maxLen);
        }
```

另外一种写法

- `k`为遍历的字符长度，可以为`n` 即当`i=0`的时候

```java
        public String longestPalindrome(String s) {
            if (s == null || s.length() <= 0) return s;
            int n = s.length();
            boolean[][] f = new boolean[n][n];
            for (int i = 0; i < n; i++) f[i][i] = true;
            int maxLen = 1, start = 0;
            for (int i = n - 1; i >= 0; i--) {
                for (int k = 1; k < n - i; k++) {
                    int j = k + i;
                    if (s.charAt(i) == s.charAt(j)) {
                        f[i][j] = (k == 1) || f[i + 1][j - 1];
                    }
                    if (f[i][j] && j - i + 1 > maxLen) {
                        maxLen = j - i + 1;
                        start = i;
                    }
                }
            }
            return s.substring(start, start + maxLen);
        }
```

#### 方法4:中心扩展法

```java
public String longestPalindrome(String s) {
    if (s == null || s.length() == 0) {
        return "";
    }
    int n = s.length();
    int start = 0, end = 0;
    for (int i = 0; i < n; i++) {
        //获取到当前点i 的奇回文和偶回文的最大长度
        int len1 = expandBySeed(s, i, i);
        int len2 = expandBySeed(s, i, i + 1);
        //取最大长度，然后扩展
        int len = Math.max(len1, len2);
        if (len > (end - start)) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}


/**
         * 由中心往两边扩散，返回满足最大回文的长度
         *
         * @param s
         * @param start
         * @param end
         * @return
         */
private int expandBySeed(String s, int start, int end) {
    int n = s.length();
    while (start >= 0 && end < n && s.charAt(start) == s.charAt(end)) {
        start--;
        end++;
    }
    return end - start - 1;
}
```

#### 方法5:Manacher算法

> 本动态规划的文章着重讲动态规划，涉及马拉车算法的内容不详细展开，下面的代码取自weiwei大佬的[题解](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)

```java
public class Solution {

    public String longestPalindrome(String s) {
        // 特判
        int len = s.length();
        if (len < 2) {
            return s;
        }

        // 得到预处理字符串
        String str = addBoundaries(s, '#');
        // 新字符串的长度
        int sLen = 2 * len + 1;

        // 数组 p 记录了扫描过的回文子串的信息
        int[] p = new int[sLen];

        // 双指针，它们是一一对应的，须同时更新
        int maxRight = 0;
        int center = 0;

        // 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度
        int maxLen = 1;
        // 原始字符串的最长回文子串的起始位置，与 maxLen 必须同时更新        
        int start = 0;

        for (int i = 0; i < sLen; i++) {
            if (i < maxRight) {
                int mirror = 2 * center - i;
                // 这一行代码是 Manacher 算法的关键所在，要结合图形来理解
                p[i] = Math.min(maxRight - i, p[mirror]);
            }

            // 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中
            int left = i - (1 + p[i]);
            int right = i + (1 + p[i]);

            // left >= 0 && right < sLen 保证不越界
            // str.charAt(left) == str.charAt(right) 表示可以扩散 1 次
            while (left >= 0 && right < sLen && str.charAt(left) == str.charAt(right)) {
                p[i]++;
                left--;
                right++;

            }
            // 根据 maxRight 的定义，它是遍历过的 i 的 i + p[i] 的最大者
            // 如果 maxRight 的值越大，进入上面 i < maxRight 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了
            if (i + p[i] > maxRight) {
                // maxRight 和 center 需要同时更新
                maxRight = i + p[i];
                center = i;
            }
            if (p[i] > maxLen) {
                // 记录最长回文子串的长度和相应它在原始字符串中的起点
                maxLen = p[i];
                start = (i - maxLen) / 2;
            }
        }
        return s.substring(start, start + maxLen);
    }


    /**
     * 创建预处理字符串
     *
     * @param s      原始字符串
     * @param divide 分隔字符
     * @return 使用分隔字符处理以后得到的字符串
     */
    private String addBoundaries(String s, char divide) {
        int len = s.length();
        if (len == 0) {
            return "";
        }
        if (s.indexOf(divide) != -1) {
            throw new IllegalArgumentException("参数错误，您传递的分割字符，在输入字符串中存在！");
        }
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < len; i++) {
            stringBuilder.append(divide);
            stringBuilder.append(s.charAt(i));
        }
        stringBuilder.append(divide);
        return stringBuilder.toString();
    }
}

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





### 回文子串的个数

题目链接 ：[647. Palindromic Substrings](https://leetcode-cn.com/problems/palindromic-substrings/)

题解链接：[畅游面试中的动态规划套路-回文子序列系列之回文子串的个数](https://leetcode-cn.com/problems/palindromic-substrings/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-5gyx/)

#### 方法1:暴力递归

```java
public int countSubstrings(String s) {
    int ans = 0, n = s.length();
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            ans += helper(s, i, j);
        }
    }
    return ans;
}

private int helper(String s, int start, int end) {
    if (start >= end) return 1;
    return s.charAt(start) == s.charAt(end) ? helper(s, start + 1, end - 1) : 0;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[][] memo;

public int countSubstrings(String s) {
    int ans = 0, n = s.length();
    memo = new Integer[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            ans += helper(s, i, j);
        }
    }
    return ans;
}

private int helper(String s, int start, int end) {
    if (start >= end) return 1;
    if (memo[start][end] != null) return memo[start][end];
    return memo[start][end] = s.charAt(start) == s.charAt(end) ? helper(s, start + 1, end - 1) : 0;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

- `f[i][j]`表示`i`到`j`上的回文子串的个数，分三种情况讨论
  - 长度为1：自己和自己组成回文，回文子串个数为1
  - 长度为2：是否相等，相等则有一个回文子串，不相等则没有
  - 长度为3：一般情况，看是否相等，不相等，则为0，相等，则砍头去尾，看`f[i + 1][j - 1] `

```java
public int countSubstrings(String s) {
    int n = s.length();
    int[][] f = new int[n][n];
    char[] chas = s.toCharArray();
    int ans = 0;
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i; j < n; j++) {
            if (i == j) f[i][j] = 1;
            else if (i + 1 == j) f[i][j] = chas[i] == chas[j] ? 1 : 0;
            else f[i][j] = chas[i] == chas[j] ? f[i + 1][j - 1] : 0;
            ans += f[i][j];
        }
    }
    return ans;
}
```

#### 方法4:中心扩展法

```java
/**
 * @param s
 * @return
 */
public int countSubstrings2nd(String s) {
    int result = 0;
    for (int i = 0; i < s.length(); i++) {
        //以当前点i位置，向两边扩展,以i i+1位置向两边扩展
        result += countSegment(s, i, i);
        result += countSegment(s, i, i + 1);
    }
    return result;
}


public int countSegment(String s, int start, int end) {
    int count = 0;
    //start往左边跑，end往右边跑，注意边界
    while (start >= 0 && end < s.length() && s.charAt(start--) == s.charAt(end++)) {
        count++;
    }
    return count;
}

```









### 让字符串成为回文串的最少插入次数

题目链接：[1312. Minimum Insertion Steps to Make a String Palindrome](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

老题解链接：[动态规划解最长子序列子串等一类问题之让字符串成为回文及其Follow Up[Sika Deer]](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution/dong-tai-gui-hua-jie-zui-chang-zi-xu-lie-zi-chuan-/)

新题解链接：[畅游面试中的动态规划套路-回文子序列系列之让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-yxoa/)

#### 方法1:暴力递归

- `helper(String s, int start, int end) `表示`s`从`start`到`end`想要形成回文，最少的插入次数
- `base case`:
  - 当`start >= end`时，一个字符的时候，本身就是回文，不需要添加，大于的时候，越界，无意义
- `[start]=[end]`的时候，砍头去尾向前看
- `[start]!=[end]`的时候，前后各添加一个，进入递归找最小的

```java
public int minInsertions(String s) {
    return helper(s, 0, s.length() - 1);
}

private int helper(String s, int start, int end) {
    if (start >= end) return 0;
    int ans;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1);
    } else {
        ans = Math.min(helper(s, start, end - 1), helper(s, start + 1, end)) + 1;
    }
    return ans;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[][] memo;
public int minInsertions(String s) {
    int n = s.length();
    memo = new Integer[n][n];
    return helper(s, 0, n - 1);
}

private int helper(String s, int start, int end) {
    if (memo[start][end] != null) return memo[start][end];
    if (start >= end) return 0;
    int ans;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1);
    } else {
        ans = Math.min(helper(s, start, end - 1), helper(s, start + 1, end)) + 1;
    }
    return memo[start][end] = ans;

}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
public int minInsertions(String s) {
    // $dp[i][j]$表示子串$str[i...j]$范围内的最少添加多少个字符后，可以形成回文子串
    char[] chas = s.toCharArray();
    int n = chas.length;
    int[][] dp = new int[n][n];
    for (int j = 1; j < n; j++) {
        dp[j - 1][j] = (chas[j - 1] == chas[j]) ? 0 : 1;
        for (int i = j - 2; i >= 0; i--) {
            if (chas[i] == chas[j]) dp[i][j] = dp[i + 1][j - 1];
            else dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
        }
    }
    return dp[0][s.length() - 1];
}
```

> 另外一种解法

使用[畅游面试中的动态规划套路-回文子序列系列之最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/a-fei-xue-suan-fa-zhi-si-ke-yi-dao-ti-516-zui-chan/)递减即可

```java
public int minDelBuildPalindrome(String s) {
    int n = s.length();
    int[][] f = new int[n][n];
    for (int i = n - 1; i >= 0; i--) {//i的顺序从高到低
        f[i][i] = 1;
        for (int j = i + 1; j < n; j++) {
            if (s.charAt(i) == s.charAt(j)) f[i][j] = f[i + 1][j - 1] + 2;
            else f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
        }
    }

    return n - f[0][n - 1];
}
```

### 怎么删掉最少字符构成回文

题目链接：Minimum Deletions in a String to make it a Palindrome

题解链接：[畅游面试中的动态规划套路-回文子序列系列之怎么删掉最少字符构成回文](https://leetcode-cn.com/circle/article/KyfGfp/)

> 这题和[畅游面试中的动态规划套路-回文子序列系列之最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/a-fei-xue-suan-fa-zhi-si-ke-yi-dao-ti-516-zui-chan/)一样，相当于求最长回文子序列，相减可得 s.length()-maxLPSLen



#### 方法1:暴力递归

```java
public int minDelBuildPalindrome(String s) {
    return s.length() - helper(s, 0, s.length() - 1);
}

private int helper(String s, int start, int end) {
    if (start == end) return 1;
    if (start > end) return 0;
    int ans;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1) + 2;
    } else {
        ans = Math.max(helper(s, start, end - 1), helper(s, start + 1, end));
    }
  //  System.out.println(ans);
    return ans;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

```java
Integer[][] memo ;

public int minDelBuildPalindrome(String s) {
    memo = new Integer[s.length()][s.length()];
    return s.length() - helper(s, 0, s.length() - 1);
}

private int helper(String s, int start, int end) {
    if(memo[start][end]!=null) return memo[start][end];
    if (start == end) return 1;
    if (start > end) return 0;
    int ans;
    if (s.charAt(start) == s.charAt(end)) {
        ans = helper(s, start + 1, end - 1) + 2;
    } else {
        ans = Math.max(helper(s, start, end - 1), helper(s, start + 1, end));
    }
   // System.out.println(ans);
    return memo[start][end]=ans;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

```java
public int minDelBuildPalindrome(String s) {
    int n = s.length();
    int[][] f = new int[n][n];
    for (int i = n - 1; i >= 0; i--) {//i的顺序从高到低
        f[i][i] = 1;
        for (int j = i + 1; j < n; j++) {
            if (s.charAt(i) == s.charAt(j)) f[i][j] = f[i + 1][j - 1] + 2;
            else f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
        }
    }

    return n - f[0][n - 1];
}
```



### 分割回文串

题目链接 ：[131. Palindrome Partitioning](https://leetcode-cn.com/problems/palindrome-partitioning/)

题解链接：[畅游面试中的动态规划套路-回文子序列系列之分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/solution/chang-you-mian-shi-zhong-de-dong-tai-gui-yv16/)

#### 方法1:暴力递归

- `dfs(String s)` 返回当前字符`s`所能分割的回文串的组合
- 先判断左部分是不是回文，不是回文跳过，是回文，再递归去拿右部分的回文串组合
- 出口条件是当前的字符串为空的时候，也就是分割结束

```java
public List<List<String>> partition(String s) {
    return  dfs(s);
}

private List<List<String>> dfs(String s) {
    List<List<String>> res = new ArrayList<>();
    if (s == null || s.length() == 0) res.add(new ArrayList<>());
    for (int i = 0; i < s.length(); i++) {
        if (isPalindrome(s, 0, i)) {
            String left = s.substring(0, i + 1);
            for (List<String> rightList : dfs(s.substring(i + 1))) {
                List<String> sub = new ArrayList<>();
                sub.add(left);
                sub.addAll(rightList);
                res.add(sub);
            }
        }
    }
    return res;
}


private boolean isPalindrome(String s, int l, int r) {
    while (l < r) if (s.charAt(l++) != s.charAt(r--)) return false;
    return true;
}
```

- 另外一种写法

```java
List<List<String>> res = new ArrayList<>();

public List<List<String>> partition(String s) {
    dfs(s, 0, s.length(), new ArrayList<>());
    return res;
}


private void dfs(String s, int curr, int total, ArrayList<String> sub) {
    if (curr == total) {
        res.add(new ArrayList<>(sub));
        return;
    }
    for (int i = curr; i < total; i++) {
        if (isPalindrome(s, curr, i)) {
            sub.add(s.substring(curr, i + 1));
            dfs(s, i + 1, total, sub);
            sub.remove(sub.size() - 1);
        }
    }
}

private boolean isPalindrome(String s, int l, int r) {
    while (l < r) if (s.charAt(l++) != s.charAt(r--)) return false;
    return true;
}
```

#### 方法2:自顶向下记忆化递归(Top-down)

> 脱胎于方法1

```java
Map<String, List<List<String>>> memo = new HashMap<>();

public List<List<String>> partition(String s) {
    List<List<String>> dfs = dfs(s);
    return dfs;
}

private List<List<String>> dfs(String s) {
    if (memo.containsKey(s)) return memo.get(s);
    List<List<String>> res = new ArrayList<>();
    if (s == null || s.length() == 0) res.add(new ArrayList<>());
    for (int i = 0; i < s.length(); i++) {
        if (isPalindrome(s, 0, i)) {
            String left = s.substring(0, i + 1);
            //右部分从i+1开始
            for (List<String> rightList : dfs(s.substring(i + 1))) {
                List<String> sub = new ArrayList<>();
                sub.add(left);
                sub.addAll(rightList);
                res.add(sub);
            }
        }
    }
    memo.put(s, res);
    return res;
}


private boolean isPalindrome(String s, int l, int r) {
    while (l < r) if (s.charAt(l++) != s.charAt(r--)) return false;
    return true;
}
```

#### 方法3:自底向上填表DP(Bottom-up)

- `dp[i][j]`表示`[i...j]`范围内子串能否形成回文，先初始化该`dp`表

```java
List<List<String>> res = new ArrayList<>();

public List<List<String>> partition(String s) {
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    for (int j = 0; j < n; j++) {
        for (int i = 0; i <= j; i++) {
            if (s.charAt(i) == s.charAt(j) && (j - i < 2 || dp[i + 1][j - 1])) dp[i][j] = true;
        }
    }
    dfs(s, 0, n, new ArrayList<>(), dp);
    return res;
}

private void dfs(String s, int i, int n, List<String> sub, boolean[][] dp) {
    if (i == n) {
        res.add(new ArrayList<>(sub));
        return;
    }
    for (int j = i; j < n; j++) {
        if (dp[i][j]) {
            sub.add(s.substring(i, j + 1));
            dfs(s, j + 1, n, sub, dp);
            sub.remove(sub.size() - 1);
        }
    }
}
```







## 5.最长子串

### 一些名词

- 最长上升子序列($LIS$):**`Longest Increasing Subsequence `**
- 最长连续序列($LCS$):**`Longest Consecutive Sequence `**
- 最长连续递增序列($LCIS$):**`Longest Continuous Increasing Subsequence`**
- 最长公共子序列($LCS$):**`Longest Common Subsequence`**





#### [1143. Longest Common Subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/)



#### [300. Longest Increasing Subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence/)



#### [1044. Longest Duplicate Substring](https://leetcode-cn.com/problems/longest-duplicate-substring/)





#### [1027. Longest Arithmetic Subsequence](https://leetcode-cn.com/problems/longest-arithmetic-subsequence/)







#### [1092. Shortest Common Supersequence ](https://leetcode-cn.com/problems/shortest-common-supersequence/)



Longest Common Substring，最长相同子串

https://www.lintcode.com/problem/79/





#### [1653. Minimum Deletions to Make String Balanced](https://leetcode-cn.com/problems/minimum-deletions-to-make-string-balanced/)

这个有一类题







#### [72. Edit Distance](https://leetcode-cn.com/problems/edit-distance/)







#### [97. Interleaving String](https://leetcode-cn.com/problems/interleaving-string/)





Maximum Sum Increasing Subsequence | DP-14



https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/



题目链接：[509. Fibonacci Number](https://leetcode-cn.com/problems/fibonacci-number/)

题解链接：[畅游面试中的动态规划套路-斐波那契数列系列之菲波那切数列](

#### 方法1:暴力递归



#### 方法2:自顶向下记忆化递归(Top-down)



#### 方法3:自底向上填表DP(Bottom-up)







## Reference

https://github.com/search?q=Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews

https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews/RM1BDv71V60

https://blog.csdn.net/IBelieve2016/article/details/104544763