## 包含路径秩和压缩的并查集算法

在之前的文章中，讨论了并查集的朴素版本

```java
// Naive implementation of find
static int find(int parent[], int i)
{
    if (parent[i] == -1)
        return i;
    return find(parent, parent[i]);
}
   
// Naive implementation of union()
static void Union(int parent[], int x, int y)
{
    int xset = find(parent, x);
    int yset = find(parent, y);
    parent[xset] = yset;
}
```

上面的$union()$和$find()$是朴素的，最坏情况下的时间复杂度是线性的。为表示子集而创建的树可以倾斜，并且可以变得像一个链表。以下是最坏情况的示例

```java
Let there be 4 elements 0, 1, 2, 3

Initially, all elements are single element subsets.
0 1 2 3 

Do Union(0, 1)
   1   2   3  
  /
 0

Do Union(1, 2)
     2   3   
    /
   1
 /
0

Do Union(2, 3)
         3    
        /
      2
     /
   1
 /
0
```

- 上述操作在最坏情况下可以优化为$O(Log n)$​。这个想法是总是在更深的树的根下附加更小的深度树。这种技术称为**union by rank**。
- 首选术语**秩rank**而不是**高度height**，因为如果使用路径压缩技术（我们在下面讨论），那么**秩rank**并不总是等于**高度height**。
- 此外，树的**大小size**（代替**高度height**）也可以用作**秩rank**。使用**大小size**作为**秩rank**也会产生 **O(Logn)** 的最坏情况时间复杂度。

```java
Let us see the above example with union by rank
Initially, all elements are single element subsets.
0 1 2 3 

Do Union(0, 1)
   1   2   3  
  /
 0

Do Union(1, 2)
   1    3
 /  \
0    2

Do Union(2, 3)
    1    
 /  |  \
0   2   3
```

- 对朴素方法的第二个优化是**Path Compression**。这个想法是在调用**find()**时压平树。当为元素 $x$调用**find()** ，返回树的根。在**find()**操作从$x$出发找到根。
- 路径压缩**Path Compression**的想法是将找到的根作为 $x$​ 的父节点，这样我们就不必再次遍历所有中间节点。如果 x 是子树的根，那么 x 下所有节点的路径（到根）也会压缩。

```java
Let the subset {0, 1, .. 9} be represented as below and find() is called
for element 3.
              9
         /    |    \  
        4     5      6
     /     \        /  \
    0        3     7    8
            /  \
           1    2  

When find() is called for 3, we traverse up and find 9 as representative
of this subset. With path compression, we also make 3 as the child of 9 so 
that when find() is called next time for 1, 2 or 3, the path to root is reduced.

              9 
         /    /  \    \
        4    5    6     3 
     /           /  \   /  \
  0            7    8  1   2
```

>  **秩rank**与路径压缩**Path Compression**带来的好处也很明显，每个操作的时间复杂度变得甚至小于 O(Logn)，摊销的时间复杂度甚至能达到常数级别

### Code:

