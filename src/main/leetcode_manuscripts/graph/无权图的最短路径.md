## 无权图的最短路径



### Approach：

- 一种解决方案是使用**Bellman-Ford算法**在 O(VE) 时间内求解。
- 如果没有负权重环的话，那么可以使用**Dijkstra 算法**在 O(E + VLogV) 时间内求解。 
- 由于图是无权的，可以在 O(V + E) 时间内解决这个问题。这个想法是使用**广度优先搜索**的修改版本，其中我们在进行广度优先搜索时继续存储给定顶点的**predecessor**。即使图中存在负权重环，该算法也可以完成。 
- 我们首先初始化一个数组 **dist[0, 1, ...., v-1]** ，使得 **dist[i]** 存储**顶点 i** 与**源顶点source**的距离
- 数组 **pred[0, 1, ....., v-1]**，使得 **pred[i]** 表示从源开始的广度优先搜索中**顶点 i 的直接前驱 immediate predecessor** 。 
- 现在我们在 O(1) 时间内从数组 d 中获得从**源顶点source**到任何其他顶点的路径长度，并且为了打印从源到任何顶点的路径，我们可以使用数组 p 并且在最坏的情况下将花费 O(V) 时间，因为 V 是数组 P 的大小。所以算法的大部分时间都花在从给定的**源顶点source**进行广度优先搜索上，我们知道这需要 O(V+E) 时间。因此我们算法的时间复杂度是 O(V+E)

### Code:





