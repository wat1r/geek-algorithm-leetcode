## 搜索与图论之欧拉回路与欧拉路径

### 前置背景

> AOV&AOE

$AOV$网，顶点表示活动，弧表示活动间的优先关系的有向图。 即如果a->b,那么a是b的先决条件。

$AOE$网，边表示活动，是一个带权的有向无环图， 其中顶点表示事件，弧表示活动，权表示活动持续时间。

求拓扑序列就是$AOV$，求关键路径就是$AOE$

##### **入度**

> 入度(indegree)就是有向图中指向这个点的边的数量，即有向图的某个顶点作为终点的次数和

##### **出度**

> 出度(outdegree)就是从这个点出去的边的数量，即有向图的某个顶点作为起点的次数和

##### 定义

- **欧拉回路（`Eulerian Circuit`）**：**从图上一个点u出发不重复地经过每一条边后，再次回到点u的一条路径。**
- **欧拉路径（`Eulerian Path`）**:**从图上一个点u出发不重复地经过每一条边的一条路径（不必回到点u）。**
- **欧拉图即存在欧拉回路的图，半欧拉图即存在欧拉路径的图**

就像是一笔画，要求每条边只走一次，但每个点可以多次经过，而要求每个点只走一次的模型是**哈密顿环。**注意欧拉回路必须回到起点，欧拉路径则不必，可以说欧拉回路一定是欧拉路径，反之不成立

|            | 欧拉回路                     | 欧拉路径                                                     |
| ---------- | ---------------------------- | ------------------------------------------------------------ |
| **无向图** | 每个节点都有偶数的**度**     | 每个节点都有偶数的度**或者**只有两个节点有用奇数的**度**（这个两个奇数度的节点其实是起点和终点） |
| **有向图** | 每个节点都有相同的入度和出度 | 最多只有一个顶点的**入度-出度=1**并且最多只有一个顶点的**出度-入度=1**,其他节点的出度与入度相等 |

##### 其他结论

- **无向图为（半）欧拉图时，只需用1笔画成；无向图为非（半）欧拉图时，即奇点（度为奇数的点）数k>2，需用k/2笔画成。**

- **可以用加边的方式把一个非欧拉图变成欧拉图。对于无向图来说，每个奇点都需加一个度，加的边为 奇点数/2 ；对于有向图来说，每个点都需加上入度与出度之差，加的边数为每个点入度与出度之差的绝对值之和再除以2。**

### [332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

#### 方法1：DFS朴素版

```java
public List<String> findItinerary(List<List<String>> tickets) {
    List<String> res = new ArrayList<>();
    Map<String, List<String>> graph = new HashMap<>();
    for (List<String> t : tickets) {
        String u = t.get(0), v = t.get(1);
        graph.putIfAbsent(u, new ArrayList<>());
        graph.get(u).add(v);
    }
    for (List<String> values : graph.values()) Collections.sort(values);
    dfs(graph, res, "JFK");
    return res;
}


private void dfs(Map<String, List<String>> graph, List<String> res, String u) {
    List<String> nexts = graph.get(u);
    while (nexts != null && nexts.size() > 0) {
        String v = nexts.remove(0);
        dfs(graph, res, v);
    }
    res.add(0, u);
}
```



#### 方法2：DFS+优先队列

- `PriorityQueue`已经默认是最小字典序，免去了排序的操作

```java
public List<String> findItinerary(List<List<String>> tickets) {
    Map<String, PriorityQueue<String>> graph = new HashMap<>();
    for (List<String> t : tickets) {
        String u = t.get(0), v = t.get(1);
        graph.putIfAbsent(u, new PriorityQueue<>());
        graph.get(u).offer(v);
    }
    Stack<String> stack = new Stack<>();
    dfs(graph, stack, "JFK");
    List<String> res = new ArrayList<>();
    while (!stack.isEmpty()) res.add(stack.pop());
    return res;
}

private void dfs(Map<String, PriorityQueue<String>> graph, Stack<String> stack, String u) {
    PriorityQueue<String> nexts = graph.get(u);
    while (nexts != null && nexts.size() > 0) {
        String v = nexts.poll();
        dfs(graph, stack, v);
    }
    stack.push(u);
}
```



### [753. 破解保险箱](https://leetcode-cn.com/problems/cracking-the-safe/)



### 79：单词搜索





### 





#### Fluery算法和Hierholzer算法

https://blog.csdn.net/Touchig/article/details/84804871)
以及Hierholzer’s Algorithm算法
https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/



https://blog.csdn.net/guomutian911/article/details/42105127