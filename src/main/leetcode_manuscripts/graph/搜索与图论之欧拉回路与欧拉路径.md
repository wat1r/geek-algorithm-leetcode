## 搜索与图论之欧拉回路与欧拉路径

![background-2069029_640](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\graph\搜索与图论之欧拉回路与欧拉路径.assets\background-2069029_640.jpg)

### 前置背景

> AOV&AOE

$AOV$网，顶点表示活动，弧表示活动间的优先关系的有向图。 即如果a->b,那么a是b的先决条件。

$AOE$网，边表示活动，是一个带权的有向无环图， 其中顶点表示事件，弧表示活动，权表示活动持续时间。

求拓扑序列就是$AOV$，求关键路径就是$AOE$

##### **入度**

> 入度(indegree)就是有向图中指向这个点的边的数量，即有向图的某个顶点作为终点的次数和

##### **出度**

> 出度(outdegree)就是从这个点出去的边的数量，即有向图的某个顶点作为起点的次数和

##### 定义

- **欧拉回路（`Eulerian Circuit`）**：**从图上一个点u出发不重复地经过每一条边后，再次回到点u的一条路径。**
- **欧拉路径（`Eulerian Path`）**:**从图上一个点u出发不重复地经过每一条边的一条路径（不必回到点u）。**
- **欧拉图即存在欧拉回路的图，半欧拉图即存在欧拉路径的图**
- **欧拉迹/欧拉通路/一笔画：通过图中每条边且行遍所有顶点的迹（每条边恰一次的途径），称为欧拉迹（Euler trail）**
- **半欧拉图：具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图，有且仅有两个度数为奇数的结点**
- **环游：图的环游(tour)是指经过图的每条边至少一次的闭途径**
- **欧拉环游/回路：经过每条边恰好一次的环游/回路欧拉环游/回路（Eular tour）**
- **欧拉图：一个图若包含欧拉环游，则称为欧拉图(Euleriangraph)**
- **欧拉定理：一个非空连通图是欧拉图当且仅当它的每个顶点的度数都是偶数**

就像是一笔画，要求每条边只走一次，但每个点可以多次经过，而要求每个点只走一次的模型是**哈密顿环。**注意欧拉回路必须回到起点，欧拉路径则不必，可以说欧拉回路一定是欧拉路径，反之不成立

|            | 欧拉回路                     | 欧拉路径                                                     |
| ---------- | ---------------------------- | ------------------------------------------------------------ |
| **无向图** | 每个节点都有偶数的**度**     | 每个节点都有偶数的度**或者**只有两个节点有奇数的**度**（这个两个奇数度的节点其实是起点和终点） |
| **有向图** | 每个节点都有相同的入度和出度 | 最多只有一个顶点的**入度-出度=1**并且最多只有一个顶点的**出度-入度=1**,其他节点的出度与入度相等 |

##### 其他结论

- **无向图为（半）欧拉图时，只需用1笔画成；无向图为非（半）欧拉图时，即奇点（度为奇数的点）数k>2，需用k/2笔画成。**

- **可以用加边的方式把一个非欧拉图变成欧拉图。对于无向图来说，每个奇点都需加一个度，加的边为 奇点数/2 ；对于有向图来说，每个点都需加上入度与出度之差，加的边数为每个点入度与出度之差的绝对值之和再除以2。**

### [332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

#### 方法1：DFS朴素版

```java
public List<String> findItinerary(List<List<String>> tickets) {
    List<String> res = new ArrayList<>();
    Map<String, List<String>> graph = new HashMap<>();
    for (List<String> t : tickets) {
        String u = t.get(0), v = t.get(1);
        graph.putIfAbsent(u, new ArrayList<>());
        graph.get(u).add(v);
    }
    for (List<String> values : graph.values()) Collections.sort(values);
    dfs(graph, res, "JFK");
    return res;
}


private void dfs(Map<String, List<String>> graph, List<String> res, String u) {
    List<String> nexts = graph.get(u);
    while (nexts != null && nexts.size() > 0) {
        String v = nexts.remove(0);
        dfs(graph, res, v);
    }
    res.add(0, u);
}
```



#### 方法2：DFS+优先队列（Hierholzer算法）

- `PriorityQueue`已经默认是最小字典序，免去了排序的操作

```java
public List<String> findItinerary(List<List<String>> tickets) {
    Map<String, PriorityQueue<String>> graph = new HashMap<>();
    for (List<String> t : tickets) {
        String u = t.get(0), v = t.get(1);
        graph.putIfAbsent(u, new PriorityQueue<>());
        graph.get(u).offer(v);
    }
    Stack<String> stack = new Stack<>();
    dfs(graph, stack, "JFK");
    List<String> res = new ArrayList<>();
    while (!stack.isEmpty()) res.add(stack.pop());
    return res;
}

private void dfs(Map<String, PriorityQueue<String>> graph, Stack<String> stack, String u) {
    PriorityQueue<String> nexts = graph.get(u);
    while (nexts != null && nexts.size() > 0) {
        String v = nexts.poll();
        dfs(graph, stack, v);
    }
    stack.push(u);
}
```



#### 方法3：Fleury算法

```java
Map<String, List<String>> graph = new HashMap<>();
        List<String> res = new ArrayList<>();

        public List<String> findItinerary(List<List<String>> tickets) {
            for (List<String> t : tickets) {
                String u = t.get(0), v = t.get(1);
                graph.putIfAbsent(u, new ArrayList<>());
                graph.get(u).add(v);

            }
            for (List<String> values : graph.values()) Collections.sort(values);
            String u = "JFK";
            res.add(u);
            fleuryProcess(u);
            return res;

        }


        private void fleuryProcess(String u) {
            if (graph.containsKey(u)) {
                for (int i = 0; i < graph.get(u).size(); i++) {
                    String v = graph.get(u).get(i);
                    if (isValidNextEdge(u, v)) {
                        res.add(v);
                        graph.get(u).remove(v);
                        fleuryProcess(v);
                    }
                }
            }

        }


        private boolean isValidNextEdge(String u, String v) {
            if (graph.get(u).size() == 1) return true;
//            boolean[] visited = new boolean[graph.get(u).size()];
            Map<String, Boolean> visited = new HashMap<>();
            int count1 = dfs(u, visited);
            graph.get(u).remove(v);
            visited = new HashMap<>();
            int count2 = dfs(v, visited);
            graph.get(u).add(0, v);
            return count1 <= count2;
        }

        private int dfs(String u, Map<String, Boolean> visited) {
            visited.put(u, true);
            int count = 1;
            System.out.printf("%s\n", u);
            if (graph.containsKey(u)) {
                for (String adj : graph.get(u)) {
                    if (visited.get(adj) == null || (visited.get(adj) != null && !visited.get(adj))) {
                        count += dfs(adj, visited);
                    }
                }
            }
            return count;
        }
```







### [753. 破解保险箱](https://leetcode-cn.com/problems/cracking-the-safe/)



### 79：单词搜索





### 







### Reference

- [一文掌握Fleury算法](https://blog.csdn.net/wat1r/article/details/113766053)
- [一文掌握Hierholzer算法](https://blog.csdn.net/wat1r/article/details/113762786)

- [Hierholzer’s Algorithm for directed graph](https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/)





#### Fluery算法和Hierholzer算法

https://blog.csdn.net/Touchig/article/details/84804871)
以及Hierholzer’s Algorithm算法
https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/



https://blog.csdn.net/guomutian911/article/details/42105127

https://blog.csdn.net/a435262767/article/details/105253850